"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
var decimal_js_light_1 = __importDefault(require("decimal.js-light"));
var simpleStringTypes = ["string", "email", "phone", "html", "xml"];
var simpleTypes = __spreadArray(["json", "bool", "url", "int", "uint", "float", "money", "hex", "uuid", "base64", "void"], simpleStringTypes, true);
var ParseError = /** @class */ (function (_super) {
    __extends(ParseError, _super);
    function ParseError(path, type, value) {
        var str;
        try {
            str = JSON.stringify(value);
        }
        catch (err) {
            str = String(value);
        }
        return _super.call(this, "Invalid type at '".concat(path, "', expected ").concat(String(type), ", got ").concat(str)) || this;
    }
    return ParseError;
}(Error));
function simpleEncodeDecode(path, type, value) {
    if (type === "json") {
        if (value === null || value === undefined) {
            return null;
        }
        return JSON.parse(JSON.stringify(value));
    }
    else if (type === "bool") {
        if (typeof value !== "boolean") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (simpleStringTypes.indexOf(type) >= 0) {
        if (typeof value !== "string") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "hex") {
        if (typeof value !== "string" || !/^(?:[A-Fa-f0-9]{2})*$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        return value.toLowerCase();
    }
    else if (type === "uuid") {
        if (typeof value !== "string" || !/^[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        return value.toLowerCase();
    }
    else if (type === "base64") {
        var isValidBase64 = true;
        try {
            atob(value);
        }
        catch (_a) {
            isValidBase64 = false;
        }
        if (typeof value !== "string" || !isValidBase64) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "int") {
        if (typeof value !== "number" || (value | 0) !== value) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "uint") {
        if (typeof value !== "number" || (value | 0) !== value || value < 0) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "float") {
        if (typeof value !== "number") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "money") {
        if (typeof value !== "number" || !Number.isInteger(value)) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "url") {
        var url = void 0;
        if (typeof value === "string") {
            try {
                url = new URL(value);
            }
            catch (e) {
                // ignore
            }
        }
        if (!url) {
            throw new ParseError(path, type, value);
        }
        return url.toString();
    }
    else if (type === "void") {
        return null;
    }
    throw new Error("Unknown type '".concat(type, "' at '").concat(path, "'"));
}
function encode(typeTable, path, type, value) {
    if (typeof type === "string" && !type.endsWith("?") && type !== "void" && (value === null || value === undefined)) {
        throw new Error("Invalid type at '".concat(path, "', cannot be null"));
    }
    else if (Array.isArray(type)) {
        for (var _i = 0, type_1 = type; _i < type_1.length; _i++) {
            var entry = type_1[_i];
            if (entry === value) {
                return value;
            }
            if (Array.isArray(value) && value.length === 2 && entry === value[0]) {
                return value[0];
            }
            if (Array.isArray(entry) && entry.length === 2) {
                if (entry[0] === value) {
                    return [value, encode(typeTable, "".concat(path, ".").concat(entry[0]), entry[1], {})];
                }
                else if (Array.isArray(value) && value.length === 2 && entry[0] === value[0]) {
                    return [value[0], encode(typeTable, "".concat(path, ".").concat(entry[0]), entry[1], value[1])];
                }
            }
        }
        throw new ParseError(path, type, value);
    }
    else if (typeof type === "object") {
        if (typeof value !== "object") {
            throw new ParseError(path, type, value);
        }
        var obj = {};
        for (var _a = 0, _b = Object.keys(type); _a < _b.length; _a++) {
            var key = _b[_a];
            obj[key] = encode(typeTable, "".concat(path, ".").concat(key), type[key], value[key]);
        }
        return obj;
    }
    else if (type.endsWith("?")) {
        if (value === null || value === undefined) {
            return null;
        }
        return encode(typeTable, path, type.slice(0, type.length - 1), value);
    }
    else if (type.endsWith("[]")) {
        if (!Array.isArray(value)) {
            throw new ParseError(path, type, value);
        }
        return value.map(function (entry, index) { return encode(typeTable, "".concat(path, "[").concat(index, "]"), type.slice(0, type.length - 2), entry); });
    }
    else if (simpleTypes.indexOf(type) >= 0) {
        return simpleEncodeDecode(path, type, value);
    }
    else if (type === "bytes") {
        if (!(value instanceof ArrayBuffer)) {
            throw new ParseError(path, type, value);
        }
        return btoa(String.fromCharCode.apply(String, new Uint8Array(value)));
    }
    else if (type === "bigint") {
        if (!(typeof value === "bigint")) {
            throw new ParseError(path, type, value);
        }
        // eslint-disable-next-line @typescript-eslint/no-base-to-string
        return value.toString();
    }
    else if (type === "cpf") {
        if (typeof value !== "string") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "cnpj") {
        if (typeof value !== "string") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "date") {
        if (!(value instanceof Date && !isNaN(value.getTime())) && !(typeof value === "string" && /^[0-9]{4}-[01][0-9]-[0123][0-9]$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        var dateValue = value instanceof Date ? value : new Date(value);
        return "".concat(dateValue.getFullYear().toString().padStart(4, "0"), "-").concat((dateValue.getMonth() + 1).toString().padStart(2, "0"), "-").concat(dateValue
            .getDate()
            .toString()
            .padStart(2, "0"));
    }
    else if (type === "datetime") {
        if (!(value instanceof Date && !isNaN(value.getTime())) &&
            !(typeof value === "string" &&
                /^[0-9]{4}-[01][0-9]-[0123][0-9]T[012][0-9]:[0123456][0-9]:[0123456][0-9](?:\.[0-9]{1,6})?(?:Z|[+-][012][0-9]:[0123456][0-9])?$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        return (typeof value === "string" ? new Date(value) : value).toISOString().replace("Z", "");
    }
    else if (type === "decimal") {
        if (typeof value !== "number" && (typeof value !== "string" || !/^-?[0-9]+(?:\.[0-9]+)?$/u.test(value)) && !(value instanceof decimal_js_light_1.default)) {
            throw new ParseError(path, type, value);
        }
        return new decimal_js_light_1.default(value).toString();
    }
    else {
        var resolved = typeTable[type];
        if (resolved) {
            return encode(typeTable, path, resolved, value);
        }
        throw new Error("Unknown type '".concat(type, "' at '").concat(path, "'"));
    }
}
exports.encode = encode;
function decode(typeTable, path, type, value) {
    if (typeof type === "string" && !type.endsWith("?") && type !== "void" && (value === null || value === undefined)) {
        throw new Error("Invalid type at '".concat(path, "', cannot be null"));
    }
    else if (Array.isArray(type)) {
        for (var _i = 0, type_2 = type; _i < type_2.length; _i++) {
            var entry = type_2[_i];
            if (entry === value) {
                return value;
            }
            if (Array.isArray(value) && value.length === 2 && entry === value[0]) {
                return value[0];
            }
            if (Array.isArray(entry) && entry.length === 2) {
                if (entry[0] === value) {
                    return [value, decode(typeTable, "".concat(path, ".").concat(entry[0]), entry[1], {})];
                }
                else if (Array.isArray(value) && value.length === 2 && entry[0] === value[0]) {
                    return [value[0], decode(typeTable, "".concat(path, ".").concat(entry[0]), entry[1], value[1])];
                }
            }
        }
        throw new ParseError(path, type, value);
    }
    else if (typeof type === "object") {
        if (typeof value !== "object") {
            throw new ParseError(path, type, value);
        }
        var obj = {};
        for (var _a = 0, _b = Object.keys(type); _a < _b.length; _a++) {
            var key = _b[_a];
            obj[key] = decode(typeTable, "".concat(path, ".").concat(key), type[key], value[key]);
        }
        return obj;
    }
    else if (type.endsWith("?")) {
        if (value === null || value === undefined) {
            return null;
        }
        return decode(typeTable, path, type.slice(0, type.length - 1), value);
    }
    else if (type.endsWith("[]")) {
        if (!Array.isArray(value)) {
            throw new ParseError(path, type, value);
        }
        return value.map(function (entry, index) { return decode(typeTable, "".concat(path, "[").concat(index, "]"), type.slice(0, type.length - 2), entry); });
    }
    else if (simpleTypes.indexOf(type) >= 0) {
        return simpleEncodeDecode(path, type, value);
    }
    else if (type === "bytes") {
        if (typeof value !== "string") {
            throw new ParseError(path, "".concat(type, " (base 64)"), value);
        }
        try {
            return Uint8Array.from(atob(value), function (c) { return c.charCodeAt(0); });
        }
        catch (_c) {
            throw new ParseError(path, "".concat(type, " (base 64)"), value);
        }
    }
    else if (type === "bigint") {
        if (typeof value !== "number" && (typeof value !== "string" || !/^-?[0-9]+$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        return BigInt(value);
    }
    else if (type === "cpf") {
        if (typeof value !== "string") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "cnpj") {
        if (typeof value !== "string") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "date") {
        if (typeof value !== "string" || !/^[0-9]{4}-[01][0-9]-[0123][0-9]$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        var day = parseInt(value.split("-")[2], 10);
        var month = parseInt(value.split("-")[1], 10) - 1;
        var year = parseInt(value.split("-")[0], 10);
        var date = new Date(year, month, day);
        if (date.getFullYear() !== year || date.getMonth() !== month || date.getDate() !== day) {
            throw new ParseError(path, type, value);
        }
        return date;
    }
    else if (type === "datetime") {
        if (typeof value !== "string" || !/^[0-9]{4}-[01][0-9]-[0123][0-9]T[012][0-9]:[0123456][0-9]:[0123456][0-9](?:\.[0-9]{1,6})?Z?$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        return new Date("".concat(value.endsWith("Z") ? value : value.concat("Z")));
    }
    else if (type === "decimal") {
        if (typeof value !== "number" && (typeof value !== "string" || !/^-?[0-9]+(?:\.[0-9]+)?$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        return new decimal_js_light_1.default(value);
    }
    else {
        var resolved = typeTable[type];
        if (resolved) {
            return decode(typeTable, path, resolved, value);
        }
        throw new Error("Unknown type '".concat(type, "' at '").concat(path, "'"));
    }
}
exports.decode = decode;
