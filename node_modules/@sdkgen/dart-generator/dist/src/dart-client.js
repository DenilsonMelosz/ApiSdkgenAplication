"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDartClientSource = void 0;
const parser_1 = require("@sdkgen/parser");
const helpers_1 = require("./helpers");
function generateDartClientSource(ast) {
    let code = "";
    code += `// ignore_for_file: constant_identifier_names
`;
    if ((0, parser_1.hasType)(ast, parser_1.BytesPrimitiveType)) {
        code += `import 'dart:typed_data';
`;
    }
    if ((0, parser_1.hasType)(ast, parser_1.DecimalPrimitiveType)) {
        code += `import 'package:decimal/decimal.dart';
`;
    }
    code += `import 'package:http/http.dart' as http;
import 'package:sdkgen_runtime/types.dart';
import 'package:sdkgen_runtime/http_client.dart';
`;
    for (const type of ast.enumTypes) {
        code += (0, helpers_1.generateEnum)(type);
        code += "\n";
    }
    for (const type of ast.structTypes) {
        code += (0, helpers_1.generateClass)(type);
        code += "\n";
    }
    for (const error of ast.errors) {
        code += (0, helpers_1.generateErrorClass)(error);
        code += "\n";
    }
    code += `class ApiClient extends SdkgenHttpClient {
  ApiClient(String baseUrl, [http.Client? client]) : super(baseUrl, client, _typeTable, _fnTable, _errTable);
${ast.operations
        .filter(op => op.annotations.every(ann => !(ann instanceof parser_1.HiddenAnnotation)))
        .map(op => `
  ${op.returnType instanceof parser_1.VoidPrimitiveType ? "Future<void> " : `Future<${(0, helpers_1.generateTypeName)(op.returnType)}> `}${op.name}(${op.args.length === 0
        ? ""
        : `{${op.args
            .map(arg => `${arg.type instanceof parser_1.OptionalType ? "" : "required "}${(0, helpers_1.generateTypeName)(arg.type)} ${(0, helpers_1.mangle)(arg.name)}`)
            .join(", ")}}`}) async { ${op.returnType instanceof parser_1.VoidPrimitiveType ? "" : "return "}${(0, helpers_1.cast)(`await makeRequest('${op.name}', {${op.args.map(arg => `'${arg.name}': ${(0, helpers_1.mangle)(arg.name)}`).join(", ")}})`, op.returnType)}; }`)
        .join("")}
}\n\n`;
    code += `var _typeTable = {\n`;
    for (const type of ast.structTypes) {
        code += `  '${type.name}': StructTypeDescription(\n`;
        code += `    ${type.name},\n`;
        code += `    {\n`;
        for (const field of type.fields) {
            code += `      '${field.name}': '${field.type.name}',\n`;
        }
        code += `    },\n`;
        code += `    (Map fields) => ${type.name}(\n`;
        for (const field of type.fields) {
            code += `      ${(0, helpers_1.mangle)(field.name)}: ${(0, helpers_1.cast)(`fields['${field.name}']`, field.type)},\n`;
        }
        code += `    ),\n`;
        code += `    (${type.name} obj) => ({\n`;
        for (const field of type.fields) {
            code += `      '${field.name}': obj.${(0, helpers_1.mangle)(field.name)},\n`;
        }
        code += `    }),\n`;
        code += `  ),\n`;
    }
    for (const type of ast.enumTypes) {
        code += `  '${type.name}': EnumTypeDescription(${type.name}, ${type.name}.values, [\n    ${type.values
            .map(x => `'${x.value}'`)
            .join(",\n    ")}\n  ]),\n`;
    }
    code += `};\n\n`;
    code += `var _fnTable = {\n`;
    for (const op of ast.operations) {
        code += `  '${op.name}': FunctionDescription('${op.returnType.name}', {\n`;
        for (const arg of op.args) {
            code += `    '${arg.name}': '${arg.type.name}',\n`;
        }
        code += `  }),\n`;
    }
    code += `};\n\n`;
    code += `var _errTable = {\n`;
    for (const error of ast.errors) {
        const hasData = !(error.dataType instanceof parser_1.VoidPrimitiveType);
        const dataArg = hasData ? ", data" : "";
        code += `  '${error.name}': SdkgenErrorDescription('${error.dataType.name}', (msg, req, data) => ${error.name}(msg, req${dataArg})),\n`;
    }
    code += `};\n`;
    return code;
}
exports.generateDartClientSource = generateDartClientSource;
