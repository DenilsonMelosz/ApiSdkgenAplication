"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateClass = exports.cast = exports.generateErrorClass = exports.generateTypeName = exports.generateEnum = exports.mangle = void 0;
const parser_1 = require("@sdkgen/parser");
function mangle(fieldName) {
    const mangleList = [
        "abstract",
        "as",
        "assert",
        "async",
        "await",
        "bool",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "covariant",
        "default",
        "deferred",
        "do",
        "double",
        "dynamic",
        "else",
        "enum",
        "export",
        "extends",
        "extension",
        "external",
        "factory",
        "false",
        "final",
        "finally",
        "for",
        "Function",
        "get",
        "hide",
        "if",
        "implements",
        "import",
        "in",
        "int",
        "interface",
        "is",
        "library",
        "mixin",
        "new",
        "null",
        "on",
        "operator",
        "part",
        "rethrow",
        "return",
        "set",
        "show",
        "static",
        "super",
        "switch",
        "sync",
        "this",
        "throw",
        "true",
        "try",
        "typedef",
        "var",
        "void",
        "while",
        "with",
        "yield",
    ];
    if (mangleList.includes(fieldName)) {
        return `$${fieldName}`;
    }
    return fieldName;
}
exports.mangle = mangle;
function generateEnum(type) {
    return `enum ${type.name} {\n  ${type.values.map(x => x.value).join(",\n  ")}\n}\n`;
}
exports.generateEnum = generateEnum;
function generateTypeName(type) {
    switch (type.constructor) {
        case parser_1.StringPrimitiveType:
            return "String";
        case parser_1.IntPrimitiveType:
        case parser_1.UIntPrimitiveType:
            return "int";
        case parser_1.FloatPrimitiveType:
            return "double";
        case parser_1.BigIntPrimitiveType:
            return "BigInt";
        case parser_1.DatePrimitiveType:
        case parser_1.DateTimePrimitiveType:
            return "DateTime";
        case parser_1.BoolPrimitiveType:
            return "bool";
        case parser_1.BytesPrimitiveType:
            return "Uint8List";
        case parser_1.MoneyPrimitiveType:
            return "int";
        case parser_1.DecimalPrimitiveType:
            return "Decimal";
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
            return "String";
        case parser_1.VoidPrimitiveType:
            return "void";
        case parser_1.JsonPrimitiveType:
            return "dynamic";
        case parser_1.OptionalType:
            return `${generateTypeName(type.base)}?`;
        case parser_1.ArrayType:
            return `List<${generateTypeName(type.base)}>`;
        case parser_1.StructType:
            return type.name;
        case parser_1.EnumType:
            return type.name;
        case parser_1.TypeReference:
            return generateTypeName(type.type);
        default:
            throw new Error(`BUG: generateTypeName with ${type.constructor.name}`);
    }
}
exports.generateTypeName = generateTypeName;
function generateErrorClass(error) {
    if (error.dataType instanceof parser_1.VoidPrimitiveType) {
        return `class ${error.name} extends SdkgenError {\n  ${error.name}(super.msg, super.request);\n}\n`;
    }
    const dataType = generateTypeName(error.dataType);
    return `class ${error.name} extends SdkgenErrorWithData<${dataType}> {\n  ${error.name}(super.msg, super.request, super.data);\n}\n`;
}
exports.generateErrorClass = generateErrorClass;
function cast(value, type) {
    if (type instanceof parser_1.OptionalType) {
        return `${value} == null ? null : ${cast(value, type.base)}`;
    }
    else if (type instanceof parser_1.ArrayType) {
        return `(${value} as List).map((e) => ${cast("e", type.base)}).toList()`;
    }
    else if (type instanceof parser_1.VoidPrimitiveType) {
        return value;
    }
    else if (type instanceof parser_1.FloatPrimitiveType) {
        return `(${value} as num).toDouble()`;
    }
    else if (type instanceof parser_1.MoneyPrimitiveType) {
        return `${value} as int`;
    }
    return `${value} as ${generateTypeName(type)}`;
}
exports.cast = cast;
function generateConstructor(type) {
    let str = `  ${type.name}({\n`;
    for (const field of type.fields) {
        if (field.type instanceof parser_1.OptionalType) {
            str += "    ";
        }
        else {
            str += `    required `;
        }
        str += `this.${mangle(field.name)},\n`;
    }
    str += `  });\n`;
    return str;
}
function generateEquality(type) {
    let str = `  @override\n  bool operator ==(other){\n`;
    str += `    if (identical(this, other)) return true;\n`;
    str += `    return ${[`other is ${type.name}`, ...type.fields.map(field => `${mangle(field.name)} == other.${mangle(field.name)}`)].join(" && ")};\n`;
    str += `  }\n`;
    return str;
}
function generateHashcode(type) {
    return `  @override\n  int get hashCode => Object.hashAllUnordered([${type.fields.map(field => mangle(field.name)).join(", ")}]);\n`;
}
function generateToString(type) {
    return `  @override\n  String toString() {\n    return '${type.name} { ${type.fields
        .map(field => `${field.name}: $${mangle(field.name).startsWith("$") ? `{${mangle(field.name)}}` : mangle(field.name)}`)
        .join(", ")} }';\n  }\n`;
}
function generateClass(type) {
    return `class ${type.name} {\n  ${type.fields
        .map(field => `final ${generateTypeName(field.type)} ${mangle(field.name)};`)
        .join("\n  ")}\n\n${generateConstructor(type)}\n${generateEquality(type)}\n${generateHashcode(type)}\n${generateToString(type)}}\n`;
}
exports.generateClass = generateClass;
