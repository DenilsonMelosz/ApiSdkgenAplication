"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const parser = __importStar(require("@sdkgen/parser"));
const helpers_1 = require("../src/helpers");
describe("helpers.ts", () => {
    test("generateTypescriptInterface", () => {
        const structType = new parser.StructType([]);
        structType.fields = [
            new parser.Field("int", new parser.IntPrimitiveType()),
            new parser.Field("bigint", new parser.BigIntPrimitiveType()),
            new parser.Field("date", new parser.DatePrimitiveType()),
            new parser.Field("bool", new parser.BoolPrimitiveType()),
            new parser.Field("bytes", new parser.BytesPrimitiveType()),
            new parser.Field("uuid", new parser.UuidPrimitiveType()),
            new parser.Field("void", new parser.VoidPrimitiveType()),
            new parser.Field("json", new parser.JsonPrimitiveType()),
            new parser.Field("optionalStrArray", new parser.OptionalType(new parser.ArrayType(new parser.StringPrimitiveType()))),
        ];
        structType.name = "awesomeInterface";
        expect((0, helpers_1.generateTypescriptInterface)(structType, false)).toBe(`export interface awesomeInterface {
    int: number
    bigint: bigint
    date: Date
    bool: boolean
    bytes: Buffer
    uuid: string
    void: void
    json: any
    optionalStrArray: string[] | null
}
`);
    });
    test("generateTypescriptTypeName: IntPrimitiveType", () => {
        const type = new parser.IntPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("number");
    });
    test("generateTypescriptTypeName: UIntPrimitiveType", () => {
        const type = new parser.UIntPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("number");
    });
    test("generateTypescriptTypeName: MoneyPrimitiveType", () => {
        const type = new parser.MoneyPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("number");
    });
    test("generateTypescriptTypeName: FloatPrimitiveType", () => {
        const type = new parser.FloatPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("number");
    });
    test("generateTypescriptTypeName: DateTimePrimitiveType", () => {
        const type = new parser.DateTimePrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("Date");
    });
    test("generateTypescriptTypeName: StringPrimitiveType", () => {
        const type = new parser.StringPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: CpfPrimitiveType", () => {
        const type = new parser.CpfPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: CnpjPrimitiveType", () => {
        const type = new parser.CnpjPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: EmailPrimitiveType", () => {
        const type = new parser.EmailPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: HtmlPrimitiveType", () => {
        const type = new parser.HtmlPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: UrlPrimitiveType", () => {
        const type = new parser.UrlPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: HexPrimitiveType", () => {
        const type = new parser.HexPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: Base64PrimitiveType", () => {
        const type = new parser.Base64PrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: XmlPrimitiveType", () => {
        const type = new parser.XmlPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(type, false)).toBe("string");
    });
    test("generateTypescriptTypeName: StructType", () => {
        const structType = new parser.StructType([
            new parser.Field("int", new parser.IntPrimitiveType()),
            new parser.Field("bigint", new parser.BigIntPrimitiveType()),
        ]);
        structType.name = "simpleInterface";
        expect((0, helpers_1.generateTypescriptTypeName)(structType, false)).toBe(structType.name);
    });
    test("generateTypescriptTypeName: EnumType", () => {
        const enumType = new parser.EnumType([new parser.EnumValue("value1")]);
        enumType.name = "simpleEnum";
        expect((0, helpers_1.generateTypescriptTypeName)(enumType, false)).toBe(enumType.name);
    });
    test("generateTypescriptTypeName: TypeReference", () => {
        const enumType = new parser.TypeReference("typeRef");
        enumType.type = new parser.HexPrimitiveType();
        expect((0, helpers_1.generateTypescriptTypeName)(enumType, false)).toBe("string");
    });
    test("generateTypescriptTypeName: unknown PrimitiveType error", () => {
        class UnknownType extends parser.Type {
            constructor() {
                super(...arguments);
                this.name = "UnknownType";
            }
        }
        const newUnknownType = new UnknownType();
        expect(() => (0, helpers_1.generateTypescriptTypeName)(newUnknownType, false)).toThrowError(`BUG: generateTypescriptTypeName with ${newUnknownType.name}`);
    });
});
