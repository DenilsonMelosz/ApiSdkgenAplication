"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearForLogging = exports.generateTypescriptErrorClass = exports.generateTypescriptEnum = exports.generateTypescriptInterface = exports.generateTypescriptTypeName = void 0;
const parser_1 = require("@sdkgen/parser");
function generateTypescriptTypeName(type, isBrowser) {
    switch (type.constructor) {
        case parser_1.IntPrimitiveType:
        case parser_1.UIntPrimitiveType:
        case parser_1.MoneyPrimitiveType:
        case parser_1.FloatPrimitiveType:
            return "number";
        case parser_1.BigIntPrimitiveType:
            return "bigint";
        case parser_1.DecimalPrimitiveType:
            return "Decimal";
        case parser_1.DatePrimitiveType:
        case parser_1.DateTimePrimitiveType:
            return "Date";
        case parser_1.BoolPrimitiveType:
            return "boolean";
        case parser_1.BytesPrimitiveType:
            return isBrowser ? "ArrayBuffer" : "Buffer";
        case parser_1.StringPrimitiveType:
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
            return "string";
        case parser_1.VoidPrimitiveType:
            return "void";
        case parser_1.JsonPrimitiveType:
            return "any";
        case parser_1.OptionalType:
            return `${generateTypescriptTypeName(type.base, isBrowser)} | null`;
        case parser_1.ArrayType: {
            const { base } = type;
            const baseGen = generateTypescriptTypeName(base, isBrowser);
            if (base instanceof parser_1.OptionalType) {
                return `(${baseGen})[]`;
            }
            return `${baseGen}[]`;
        }
        case parser_1.StructType:
        case parser_1.EnumType:
            return type.name;
        case parser_1.TypeReference:
            return generateTypescriptTypeName(type.type, isBrowser);
        default:
            throw new Error(`BUG: generateTypescriptTypeName with ${type.constructor.name}`);
    }
}
exports.generateTypescriptTypeName = generateTypescriptTypeName;
function generateTypescriptInterface(type, isBrowser) {
    return `export interface ${type.name} {
${type.fields.map(field => `    ${field.name}: ${generateTypescriptTypeName(field.type, isBrowser)}`).join("\n")}
}\n`;
}
exports.generateTypescriptInterface = generateTypescriptInterface;
function generateTypescriptEnum(type) {
    if (type.hasStructValues) {
        return `export type ${type.name} = ${type.values
            .map(x => (x.struct ? `({tag: "${x.value}"} & ${x.struct.name})` : `{tag: "${x.value}"}`))
            .join(" | ")};\n`;
    }
    return `export type ${type.name} = ${type.values.map(x => `"${x.value}"`).join(" | ")};\n`;
}
exports.generateTypescriptEnum = generateTypescriptEnum;
function generateTypescriptErrorClass(error, isBrowser) {
    return `export class ${error.name} extends ${error.dataType instanceof parser_1.VoidPrimitiveType ? "SdkgenError" : `SdkgenErrorWithData<${generateTypescriptTypeName(error.dataType, isBrowser)}>`} {}\n`;
}
exports.generateTypescriptErrorClass = generateTypescriptErrorClass;
function clearForLogging(path, type) {
    switch (type.constructor) {
        case parser_1.TypeReference:
            return clearForLogging(path, type.type);
        case parser_1.OptionalType: {
            const code = clearForLogging(path, type.base);
            if (code) {
                return `if (${path} !== null && ${path} !== undefined) { ${code} }`;
            }
            return "";
        }
        case parser_1.ArrayType: {
            const code = clearForLogging("el", type.base);
            if (code) {
                return `for (const el of ${path}) { ${code} }`;
            }
            return "";
        }
        case parser_1.StructType: {
            const codes = [];
            for (const field of type.fields) {
                if (field.secret) {
                    codes.push(`${path}.${field.name} = "<secret>";`);
                }
                else {
                    const code = clearForLogging(`${path}.${field.name}`, field.type);
                    if (code) {
                        codes.push(code);
                    }
                }
            }
            return codes.join(" ");
        }
        default:
            return "";
    }
}
exports.clearForLogging = clearForLogging;
