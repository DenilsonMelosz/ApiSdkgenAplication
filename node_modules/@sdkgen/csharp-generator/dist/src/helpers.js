"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateEnum = exports.generateStruct = exports.encodeType = exports.decodeType = exports.generateTypeName = exports.capitalize = exports.ident = void 0;
const parser_1 = require("@sdkgen/parser");
const reservedWords = [
    "abstract",
    "as",
    "base",
    "bool",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "checked",
    "class",
    "const",
    "continue",
    "decimal",
    "default",
    "delegate",
    "do",
    "double",
    "else",
    "enum",
    "event",
    "explicit",
    "extern",
    "false",
    "finally",
    "fixed",
    "float",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "int",
    "interface",
    "internal",
    "is",
    "lock",
    "long",
    "namespace",
    "new",
    "null",
    "object",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "ref",
    "return",
    "sbyte",
    "sealed",
    "short",
    "sizeof",
    "stackalloc",
    "static",
    "string",
    "struct",
    "switch",
    "this",
    "throw",
    "true",
    "try",
    "typeof",
    "uint",
    "ulong",
    "unchecked",
    "unsafe",
    "ushort",
    "using",
    "using",
    "static",
    "virtual",
    "void",
    "volatile",
    "while",
];
const typesWithNativeNullable = [
    parser_1.StringPrimitiveType,
    parser_1.HtmlPrimitiveType,
    parser_1.CpfPrimitiveType,
    parser_1.CnpjPrimitiveType,
    parser_1.BytesPrimitiveType,
    parser_1.EmailPrimitiveType,
    parser_1.UrlPrimitiveType,
    parser_1.UuidPrimitiveType,
    parser_1.HexPrimitiveType,
    parser_1.Base64PrimitiveType,
    parser_1.XmlPrimitiveType,
    parser_1.StructType,
    parser_1.ArrayType,
];
const needsTempVarForNullable = [
    parser_1.BigIntPrimitiveType,
    parser_1.DatePrimitiveType,
    parser_1.DateTimePrimitiveType,
    parser_1.FloatPrimitiveType,
    parser_1.IntPrimitiveType,
    parser_1.MoneyPrimitiveType,
    parser_1.DecimalPrimitiveType,
    parser_1.UIntPrimitiveType,
];
function ident(name) {
    return reservedWords.includes(name) ? `@${name}` : name;
}
exports.ident = ident;
function capitalize(name) {
    return name[0].toUpperCase() + name.slice(1);
}
exports.capitalize = capitalize;
function generateTypeName(type) {
    switch (type.constructor) {
        case parser_1.StringPrimitiveType:
            return "string";
        case parser_1.IntPrimitiveType:
            return "int";
        case parser_1.UIntPrimitiveType:
            return "uint";
        case parser_1.FloatPrimitiveType:
            return "double";
        case parser_1.BigIntPrimitiveType:
            return "BigInteger";
        case parser_1.DatePrimitiveType:
        case parser_1.DateTimePrimitiveType:
            return "DateTime";
        case parser_1.BoolPrimitiveType:
            return "bool";
        case parser_1.BytesPrimitiveType:
            return "byte[]";
        case parser_1.MoneyPrimitiveType:
        case parser_1.DecimalPrimitiveType:
            return "decimal";
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
            return "string";
        case parser_1.VoidPrimitiveType:
            return "void";
        case parser_1.JsonPrimitiveType:
            return "JsonElement";
        case parser_1.OptionalType:
            return `${generateTypeName(type.base)}?`;
        case parser_1.ArrayType:
            return `List<${generateTypeName(type.base)}>`;
        case parser_1.StructType:
            return type.name;
        case parser_1.EnumType:
            return type.name;
        case parser_1.TypeReference:
            return generateTypeName(type.type);
        default:
            throw new Error(`BUG: generateTypeName with ${type.constructor.name}`);
    }
}
exports.generateTypeName = generateTypeName;
function decodeType(type, jsonElementVar, path, targetVar, suffix = 1, maybeNull = true) {
    switch (type.constructor) {
        case parser_1.IntPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.Number || !${jsonElementVar}.TryGetInt32(out ${targetVar}))
                {
                    throw new FatalException($"'{${path}}' must be an integer");
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.UIntPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.Number || !${jsonElementVar}.TryGetUInt32(out ${targetVar}))
                {
                    throw new FatalException($"'{${path}}' must be an unsigned integer.");
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.DecimalPrimitiveType:
        case parser_1.MoneyPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.Number || !${jsonElementVar}.TryGetDecimal(out ${targetVar}) || ${targetVar} % 1 != 0)
                {
                    throw new FatalException($"'{${path}}' must be an integer amount of cents.");
                }
                ${targetVar} /= 100;
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.FloatPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.Number || !${jsonElementVar}.TryGetDouble(out ${targetVar}))
                {
                    throw new FatalException($"'{${path}}' must be a floating-point number.");
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.BigIntPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String || !BigInteger.TryParse(${jsonElementVar}.GetString(), out ${targetVar}))
                {
                    throw new FatalException($"'{${path}}' must be an arbitrarily large integer in a string.");
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.StringPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.HtmlPrimitiveType: {
            // TODO: validate HTML
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a valid HTML string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.CpfPrimitiveType: {
            // TODO: validate CPF
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a valid CPF string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.CnpjPrimitiveType: {
            // TODO: validate CNPJ
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a valid CNPJ string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.EmailPrimitiveType: {
            // TODO: validate Email
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a valid email.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.UrlPrimitiveType: {
            // TODO: validate URL
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a valid URL string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.UuidPrimitiveType: {
            // TODO: validate UUID
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a valid UUID.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.HexPrimitiveType: {
            // TODO: validate Hex
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a valid hex string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.Base64PrimitiveType: {
            // TODO: validate Base64
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a base64 string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.XmlPrimitiveType: {
            // TODO: validate XML
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a XML string.");
                }
                ${targetVar} = ${jsonElementVar}.GetString();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.BoolPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.True && ${jsonElementVar}.ValueKind != JsonValueKind.False)
                {
                    throw new FatalException($"'{${path}}' must be either true or false.");
                }
                ${targetVar} = ${jsonElementVar}.GetBoolean();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.BytesPrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String)
                {
                    throw new FatalException($"'{${path}}' must be a string.");
                }
                try
                {
                    ${targetVar} = Convert.FromBase64String(${jsonElementVar}.GetString());
                }
                catch (FormatException)
                {
                    throw new FatalException($"'{${path}}' must be a base64 string.");
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.TypeReference:
            return decodeType(type.type, jsonElementVar, path, targetVar, suffix);
        case parser_1.OptionalType:
            if (needsTempVarForNullable.includes(type.base.constructor)) {
                const tempVar = `${targetVar.replace(/[^0-9a-zA-Z]/gu, "")}Tmp`;
                return `
                    if (${jsonElementVar}.ValueKind == JsonValueKind.Null || ${jsonElementVar}.ValueKind == JsonValueKind.Undefined)
                    {
                        ${targetVar} = null;
                    }
                    else
                    {
                        ${generateTypeName(type.base)} ${tempVar};
                        ${decodeType(type.base, jsonElementVar, path, tempVar, suffix, false).replace(/\n/gu, "\n                        ")}
                        ${targetVar} = ${tempVar};
                    }
                `
                    .replace(/\n {20}/gu, "\n")
                    .trim();
            }
            return `
                    if (${jsonElementVar}.ValueKind == JsonValueKind.Null || ${jsonElementVar}.ValueKind == JsonValueKind.Undefined)
                    {
                        ${targetVar} = null;
                    }
                    else
                    {
                        ${decodeType(type.base, jsonElementVar, path, targetVar, suffix, false).replace(/\n/gu, "\n                        ")}
                    }
                `
                .replace(/\n {20}/gu, "\n")
                .trim();
        case parser_1.EnumType:
        case parser_1.StructType:
            return `${targetVar} = Decode${type.name}(${jsonElementVar}, ${path});`;
        case parser_1.JsonPrimitiveType:
            if (maybeNull) {
                return `
                if (${jsonElementVar}.ValueKind == JsonValueKind.Null || ${jsonElementVar}.ValueKind == JsonValueKind.Undefined)
                {
                    throw new FatalException($"'{${path}}' can't be null.");
                }
                ${targetVar} = ${jsonElementVar};
            `
                    .replace(/\n {16}/gu, "\n")
                    .trim();
            }
            return `${targetVar} = ${jsonElementVar};`;
        case parser_1.DateTimePrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String || !(DateTime.TryParseExact(${jsonElementVar}.GetString(), "yyyy-MM-ddTHH:mm:ss.FFFFFFF", CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out ${targetVar}) || DateTime.TryParseExact(${jsonElementVar}.GetString(), "yyyy-MM-ddTHH:mm:ss.FFFFFFF'Z'", CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out ${targetVar})))
                {
                    throw new FatalException($"'{${path}}' must be a datetime.");
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.DatePrimitiveType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.String || !(DateTime.TryParseExact(${jsonElementVar}.GetString(), "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out ${targetVar})))
                {
                    throw new FatalException($"'{${path}}' must be a date.");
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.ArrayType: {
            return `
                if (${jsonElementVar}.ValueKind != JsonValueKind.Array)
                {
                    throw new FatalException($"'{${path}}' must be a date.");
                }
                ${targetVar} = new ${generateTypeName(type)}();
                for (var i${suffix} = 0; i${suffix} < ${jsonElementVar}.GetArrayLength(); ++i${suffix})
                {
                    ${generateTypeName(type.base)} element${suffix};
                    ${decodeType(type.base, `${jsonElementVar}[i${suffix}]`, `$"{${path}}[{i${suffix}}]"`, `element${suffix}`, suffix + 1).replace(/\n/gu, "\n                    ")}
                    ${targetVar}.Add(element${suffix});
                }
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        default:
            throw new Error(`BUG: decodeType with ${type.constructor.name}`);
    }
}
exports.decodeType = decodeType;
function encodeType(type, valueVar, path, suffix = 1) {
    switch (type.constructor) {
        case parser_1.StringPrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar});`;
        }
        case parser_1.FloatPrimitiveType:
        case parser_1.UIntPrimitiveType:
        case parser_1.IntPrimitiveType: {
            return `resultWriter_.WriteNumberValue(${valueVar});`;
        }
        case parser_1.DecimalPrimitiveType:
        case parser_1.MoneyPrimitiveType: {
            return `resultWriter_.WriteNumberValue(Math.Round(${valueVar} * 100));`;
        }
        case parser_1.BigIntPrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar}.ToString());`;
        }
        case parser_1.BoolPrimitiveType: {
            return `resultWriter_.WriteBooleanValue(${valueVar});`;
        }
        case parser_1.BytesPrimitiveType: {
            return `resultWriter_.WriteStringValue(Convert.ToBase64String(${valueVar}));`;
        }
        case parser_1.DateTimePrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar}.ToString("yyyy-MM-ddTHH:mm:ss.FFFFFF'Z'"));`;
        }
        case parser_1.DatePrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar}.ToString("yyyy-MM-dd"));`;
        }
        // TODO: format those
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.XmlPrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar});`;
        }
        case parser_1.OptionalType: {
            let realBaseType = type.base;
            while (realBaseType instanceof parser_1.TypeReference) {
                realBaseType = realBaseType.type;
            }
            return `
                if (${valueVar} == null)
                {
                    resultWriter_.WriteNullValue();
                }
                else
                {
                    ${encodeType(realBaseType, typesWithNativeNullable.includes(realBaseType.constructor) ? valueVar : `${valueVar}.Value`, path, suffix).replace(/\n/gu, "\n                    ")}
                }`
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.TypeReference:
            return encodeType(type.type, valueVar, path, suffix);
        case parser_1.EnumType:
        case parser_1.StructType:
            return `Encode${type.name}(${valueVar}, resultWriter_, ${path});`;
        case parser_1.JsonPrimitiveType:
            return `${valueVar}.WriteTo(resultWriter_);`;
        case parser_1.ArrayType: {
            return `
                resultWriter_.WriteStartArray();
                for (var i${suffix} = 0; i${suffix} < ${valueVar}.Count; ++i${suffix})
                {
                    ${encodeType(type.base, `${valueVar}[i${suffix}]`, `$"{${path}}[{i${suffix}}]"`, suffix + 1).replace(/\n/gu, "\n                    ")}
                }
                resultWriter_.WriteEndArray();
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        default:
            throw new Error(`BUG: encodeType with ${type.constructor.name}`);
    }
}
exports.encodeType = encodeType;
function generateStruct(struct) {
    return `
        public class ${struct.name}
        {${struct.fields
        .map(field => `
            public ${generateTypeName(field.type)} ${capitalize(field.name)};`)
        .join("")}
            public ${struct.name}(${struct.fields.map(field => `${generateTypeName(field.type)} ${ident(field.name)}`).join(", ")})
            {${struct.fields
        .map(field => `
                ${capitalize(field.name)} = ${ident(field.name)};`)
        .join("")}
            }
        }

        ${struct.name} Decode${struct.name}(JsonElement json_, string path_)
        {
            if (json_.ValueKind != JsonValueKind.Object)
            {
                throw new FatalException($"'{path_}' must be an object.");
            }\n${struct.fields
        .map(field => `            JsonElement ${field.name}Json_;
            if (!json_.TryGetProperty(${JSON.stringify(field.name)}, out ${field.name}Json_))
            {
                ${field.type instanceof parser_1.OptionalType
        ? `${field.name}Json_ = new JsonElement();`
        : `throw new FatalException($"'{path_}.${field.name}' must be set to a value of type ${field.type.name}.");`}
            }
            ${generateTypeName(field.type)} ${ident(field.name)};
            ${decodeType(field.type, `${field.name}Json_`, `$"{path_}.${field.name}"`, ident(field.name)).replace(/\n/gu, "\n            ")}`)
        .join("\n")}
            return new ${struct.name}(${struct.fields.map(field => ident(field.name)).join(", ")});
        }

        void Encode${struct.name}(${struct.name} obj_, Utf8JsonWriter resultWriter_, string path_)
        {
            resultWriter_.WriteStartObject();
            ${struct.fields
        .map(field => `resultWriter_.WritePropertyName(${JSON.stringify(field.name)});
            ${encodeType(field.type, `obj_.${capitalize(field.name)}`, `$"{path_}.${field.name}"`).replace(/\n/gu, "\n            ")}`)
        .join("\n            ")}
            resultWriter_.WriteEndObject();
        }
`;
}
exports.generateStruct = generateStruct;
function generateEnum(type) {
    return `
        public enum ${type.name}
        {${type.values
        .map(({ value }) => `
            ${capitalize(value)}`)
        .join(",\n            ")}
        }

        ${type.name} Decode${type.name}(JsonElement json_, string path_)
        {
            if (json_.ValueKind != JsonValueKind.String)
            {
                throw new FatalException($"'{path_}' must be a string.");
            }
            var value = json_.GetString();${type.values
        .map(({ value }) => `
            if (value == "${value}")
            {
                return ${type.name}.${capitalize(value)};
            }`)
        .join("")}
            throw new FatalException($"'{path_}' must be one of: (${type.values.map(({ value }) => `'${value}'`).join(", ")}).");
        }

        void Encode${type.name}(${type.name} obj_, Utf8JsonWriter resultWriter_, string path_)
        {${type.values
        .map(({ value }) => `
            if (obj_ == ${type.name}.${capitalize(value)})
            {
                resultWriter_.WriteStringValue("${value}");
            }`)
        .join("")}
        }
`;
}
exports.generateEnum = generateEnum;
