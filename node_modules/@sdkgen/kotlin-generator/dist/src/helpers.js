"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateErrorClass = exports.generateClass = exports.getAnnotation = exports.generateEnum = exports.generateJsonAddRepresentation = exports.mangle = exports.generateKotlinTypeName = void 0;
const parser_1 = require("@sdkgen/parser");
function generateKotlinTypeName(type) {
    switch (type.constructor) {
        case parser_1.IntPrimitiveType:
        case parser_1.UIntPrimitiveType:
        case parser_1.MoneyPrimitiveType:
            return "Int";
        case parser_1.FloatPrimitiveType:
            return "Double";
        case parser_1.BigIntPrimitiveType:
            return "BigInt";
        case parser_1.DatePrimitiveType:
        case parser_1.DateTimePrimitiveType:
            return "Calendar";
        case parser_1.BoolPrimitiveType:
            return "Boolean";
        case parser_1.BytesPrimitiveType:
            return "ByteArray";
        case parser_1.StringPrimitiveType:
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
            return "String";
        case parser_1.VoidPrimitiveType:
            return "Unit";
        case parser_1.JsonPrimitiveType:
            return "@RawValue JsonElement";
        case parser_1.OptionalType:
            return `${generateKotlinTypeName(type.base)}?`;
        case parser_1.ArrayType: {
            return `ArrayList<${generateKotlinTypeName(type.base)}>`;
        }
        case parser_1.StructType:
        case parser_1.EnumType:
            return type.name;
        case parser_1.TypeReference:
            return generateKotlinTypeName(type.type);
        default:
            throw new Error(`BUG: generateKotlinTypeName with ${type.constructor.name}`);
    }
}
exports.generateKotlinTypeName = generateKotlinTypeName;
function mangle(fieldName) {
    const mangleList = [
        "in",
        "out",
        "as",
        "break",
        "class",
        "continue",
        "do",
        "else",
        "false",
        "for",
        "fun",
        "if",
        "in",
        "interface",
        "is",
        "null",
        "object",
        "package",
        "return",
        "super",
        "this",
        "throw",
        "true",
        "try",
        "typealias",
        "val",
        "var",
        "when",
        "while",
        "by",
        "catch",
        "constructor",
        "delegate",
        "dynamic",
        "field",
        "file",
        "finally",
        "get",
        "import",
        "init",
        "param",
        "property",
        "receiver",
        "set",
        "setparam",
        "where",
        "actual",
        "abstract",
        "annotation",
        "companion",
        "const",
        "crossinline",
        "data",
        "enum",
        "expect",
        "external",
        "final",
        "infix",
        "inline",
        "inner",
        "internal",
        "lateinit",
        "noinline",
        "open",
        "operator",
        "out",
        "override",
        "private",
        "protected",
        "public",
        "reified",
        "sealed",
        "suspend",
        "tailrec",
        "vararg",
        "Double",
        "Float",
        "Long",
        "Int",
        "Short",
        "Byte",
    ];
    if (mangleList.includes(fieldName)) {
        return `_${fieldName}`;
    }
    return fieldName;
}
exports.mangle = mangle;
function generateJsonAddRepresentation(type, fieldName) {
    switch (type.constructor) {
        case parser_1.StringPrimitiveType:
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
        case parser_1.IntPrimitiveType:
        case parser_1.UIntPrimitiveType:
        case parser_1.MoneyPrimitiveType:
        case parser_1.FloatPrimitiveType:
        case parser_1.BoolPrimitiveType:
            return `addProperty("${fieldName}", ${mangle(fieldName)})`;
        case parser_1.OptionalType:
            return generateJsonAddRepresentation(type.base, fieldName);
        case parser_1.DatePrimitiveType:
            return `addProperty("${fieldName}", ${mangle(fieldName)}?.let { DateAdapter.sdf.format(it.time)}) `;
        case parser_1.DateTimePrimitiveType:
            return `addProperty("${fieldName}", ${mangle(fieldName)}?.let { DateTimeAdapter.sdf.format(it.time)})`;
        case parser_1.ArrayType:
        case parser_1.StructType:
        case parser_1.EnumType:
        case parser_1.TypeReference:
        case parser_1.JsonPrimitiveType:
            return `add("${fieldName}", gson.toJsonTree(${mangle(fieldName)}))`;
        case parser_1.VoidPrimitiveType:
            return "";
        case parser_1.BytesPrimitiveType:
            return `addProperty("${fieldName}", Base64.encodeToString(${mangle(fieldName)}, Base64.NO_WRAP))`;
        default:
            throw new Error(`BUG: No result found for generateJsonRepresentation with ${type.constructor.name}`);
    }
}
exports.generateJsonAddRepresentation = generateJsonAddRepresentation;
function generateEnum(type) {
    let enumDesc = "@Parcelize \n";
    enumDesc += `   enum class ${type.name} : Parcelable { ${type.values.map(x => mangle(x.value)).join(", ")} }\n`;
    return enumDesc;
}
exports.generateEnum = generateEnum;
function getAnnotation(type, fieldName) {
    let fieldAnnotation = "";
    if (fieldName && fieldName !== mangle(fieldName)) {
        fieldAnnotation += `        @SerializedName("${fieldName}")\n`;
    }
    switch (type.constructor) {
        case parser_1.DatePrimitiveType:
            fieldAnnotation += "        @JsonAdapter(DateAdapter::class)\n";
            break;
        case parser_1.DateTimePrimitiveType:
            fieldAnnotation += "        @JsonAdapter(DateTimeAdapter::class)\n";
            break;
        case parser_1.ArrayType:
            fieldAnnotation += getAnnotation(type.base);
            break;
        case parser_1.OptionalType:
            fieldAnnotation += getAnnotation(type.base);
            break;
        default:
            break;
    }
    return fieldAnnotation;
}
exports.getAnnotation = getAnnotation;
function generateClass(type) {
    let classDesc = "@Parcelize\n";
    classDesc += `    data class ${type.name}(\n${type.fields
        .map(field => {
        let fieldDesc = getAnnotation(field.type, field.name);
        fieldDesc += `        var ${mangle(field.name)}: ${generateKotlinTypeName(field.type)}${field.type.constructor === parser_1.OptionalType ? " = null" : ""}`;
        return fieldDesc;
    })
        .join(",\n")}\n    ) : Parcelable\n`;
    return classDesc;
}
exports.generateClass = generateClass;
function generateErrorClass(error) {
    return `class ${error.name}(message: String) : Error(message)\n`;
}
exports.generateErrorClass = generateErrorClass;
