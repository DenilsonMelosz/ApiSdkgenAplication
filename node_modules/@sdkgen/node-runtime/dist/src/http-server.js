"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkgenHttpServer = void 0;
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const http_1 = require("http");
const os_1 = require("os");
const querystring_1 = require("querystring");
const url_1 = require("url");
const util_1 = require("util");
const csharp_generator_1 = require("@sdkgen/csharp-generator");
const dart_generator_1 = require("@sdkgen/dart-generator");
const fsharp_generator_1 = require("@sdkgen/fsharp-generator");
const kotlin_generator_1 = require("@sdkgen/kotlin-generator");
const parser_1 = require("@sdkgen/parser");
const playground_1 = require("@sdkgen/playground");
const swift_generator_1 = require("@sdkgen/swift-generator");
const typescript_generator_1 = require("@sdkgen/typescript-generator");
const busboy_1 = __importDefault(require("busboy"));
const file_type_1 = __importDefault(require("file-type"));
const request_ip_1 = require("request-ip");
const serve_handler_1 = __importDefault(require("serve-handler"));
const encode_decode_1 = require("./encode-decode");
const error_1 = require("./error");
const execute_1 = require("./execute");
const swagger_1 = require("./swagger");
const utils_1 = require("./utils");
class SdkgenHttpServer {
    constructor(apiConfig, ...maybeExtraContext) {
        var _a;
        this.apiConfig = apiConfig;
        this.headers = new Map();
        this.healthChecks = [];
        this.handlers = [];
        this.dynamicCorsOrigin = true;
        this.introspection = true;
        this.log = (message) => {
            console.log(`${new Date().toISOString()} ${message}`);
        };
        this.hasSwagger = false;
        this.ignoredUrlPrefix = "";
        this.handleRequest = (req, res) => {
            const hrStart = process.hrtime();
            req.on("error", err => {
                console.error(err);
                res.end();
            });
            res.on("error", err => {
                console.error(err);
                res.end();
            });
            if (this.dynamicCorsOrigin && req.headers.origin) {
                res.setHeader("Access-Control-Allow-Origin", req.headers.origin);
                res.setHeader("Vary", "Origin");
            }
            for (const [header, value] of this.headers) {
                if (req.method === "OPTIONS" && !header.startsWith("access-control-")) {
                    continue;
                }
                res.setHeader(header, value);
            }
            if (req.method === "OPTIONS") {
                res.writeHead(200);
                res.end();
                return;
            }
            const handleBody = (body) => {
                this.handleRequestWithBody(req, res, body, hrStart).catch((e) => this.writeReply(res, null, { error: e }, hrStart));
            };
            // Google Cloud Functions add a rawBody property to the request object
            if ((0, utils_1.has)(req, "rawBody") && req.rawBody instanceof Buffer) {
                handleBody(req.rawBody);
            }
            else {
                const body = [];
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                req.on("data", chunk => body.push(chunk));
                req.on("end", () => {
                    handleBody(Buffer.concat(body));
                });
            }
        };
        this.extraContext = ((_a = maybeExtraContext[0]) !== null && _a !== void 0 ? _a : {});
        this.httpServer = (0, http_1.createServer)(this.handleRequest.bind(this));
        this.enableCors();
        this.attachRestHandlers();
        const targetTable = [
            ["/targets/android/client.kt", (ast) => (0, kotlin_generator_1.generateAndroidClientSource)(ast, true)],
            ["/targets/android/client_without_callbacks.kt", (ast) => (0, kotlin_generator_1.generateAndroidClientSource)(ast, false)],
            ["/targets/dotnet/api.cs", csharp_generator_1.generateCSharpServerSource],
            ["/targets/dotnet/api.fs", fsharp_generator_1.generateFSharpServerSource],
            ["/targets/flutter/client.dart", dart_generator_1.generateDartClientSource],
            ["/targets/ios/client.swift", (ast) => (0, swift_generator_1.generateSwiftClientSource)(ast, false)],
            ["/targets/ios/client-rx.swift", (ast) => (0, swift_generator_1.generateSwiftClientSource)(ast, true)],
            ["/targets/node/api.ts", typescript_generator_1.generateNodeServerSource],
            ["/targets/node/client.ts", typescript_generator_1.generateNodeClientSource],
            ["/targets/web/client.ts", typescript_generator_1.generateBrowserClientSource],
        ];
        for (const [path, generateFn] of targetTable) {
            this.addHttpHandler("GET", path, (_req, res) => {
                if (!this.introspection) {
                    res.statusCode = 404;
                    res.end();
                    return;
                }
                try {
                    res.setHeader("Content-Type", "application/octet-stream");
                    res.write(generateFn(this.apiConfig.ast));
                }
                catch (e) {
                    console.error(e);
                    res.statusCode = 500;
                    res.write(`${e}`);
                }
                res.end();
            });
        }
        this.addHttpHandler("GET", "/ast.json", (_req, res) => {
            if (!this.introspection) {
                res.statusCode = 404;
                res.end();
                return;
            }
            res.setHeader("Content-Type", "application/json");
            res.write(JSON.stringify(apiConfig.astJson));
            res.end();
        });
        this.addHttpHandler("GET", /^\/playground.*/u, (req, res) => {
            if (!this.introspection) {
                res.statusCode = 404;
                res.end();
                return;
            }
            if (req.url) {
                req.url = req.url.endsWith("/playground") ? req.url.replace(/\/playground/u, "/index.html") : req.url.replace(/\/playground/u, "");
            }
            (0, serve_handler_1.default)(req, res, {
                cleanUrls: false,
                directoryListing: false,
                etag: true,
                public: playground_1.PLAYGROUND_PUBLIC_PATH,
            }).catch(e => {
                console.error(e);
                res.statusCode = 500;
                res.write(`${e}`);
                res.end();
            });
        });
    }
    registerHealthCheck(healthCheck) {
        this.healthChecks.push(healthCheck);
    }
    ignoreUrlPrefix(urlPrefix) {
        this.ignoredUrlPrefix = urlPrefix;
    }
    async listen(port = 8000) {
        return new Promise(resolve => {
            this.httpServer.listen(port, () => {
                const addr = this.httpServer.address();
                let urlHost;
                if (addr.address === "::") {
                    urlHost = `localhost:${addr.port}`;
                }
                else if (addr.family === "ipv6") {
                    urlHost = `[${addr.address}]:${addr.port}`;
                }
                else {
                    urlHost = `${addr.address}:${addr.port}`;
                }
                if (addr.address === "::" || addr.address === "0.0.0.0") {
                    console.log(`\nListening on port ${addr.port}`);
                }
                else {
                    console.log(`\nListening on port ${addr.port} (${addr.address})`);
                }
                if (this.introspection) {
                    console.log(`Playground: http://${urlHost}/playground`);
                }
                if (this.hasSwagger) {
                    console.log(`Swagger UI: http://${urlHost}/swagger`);
                }
                console.log("");
                resolve();
            });
        });
    }
    async close() {
        return (0, util_1.promisify)(this.httpServer.close.bind(this.httpServer))();
    }
    enableCors() {
        this.addHeader("Access-Control-Allow-Methods", "DELETE, HEAD, PUT, POST, PATCH, GET, OPTIONS");
        this.addHeader("Access-Control-Allow-Headers", "Content-Type");
        this.addHeader("Access-Control-Max-Age", "86400");
    }
    addHeader(header, value) {
        const cleanHeader = header.toLowerCase().trim();
        const existing = this.headers.get(cleanHeader);
        if (existing) {
            if (!existing.includes(value)) {
                this.headers.set(cleanHeader, `${existing}, ${value}`);
            }
        }
        else {
            this.headers.set(cleanHeader, value);
        }
    }
    addHttpHandler(method, matcher, handler) {
        this.handlers.push({ handler, matcher, method });
    }
    findBestHandler(path, req) {
        const matchingHandlers = this.handlers
            .filter(({ method }) => method === req.method)
            .filter(({ matcher }) => {
            var _a;
            if (typeof matcher === "string") {
                return matcher === path;
            }
            return ((_a = matcher.exec(path)) === null || _a === void 0 ? void 0 : _a[0]) === path;
        })
            .sort(({ matcher: first }, { matcher: second }) => {
            // Prefer string matches instead of Regexp matches
            if (typeof first === "string" && typeof second === "string") {
                return 0;
            }
            else if (typeof first === "string") {
                return -1;
            }
            else if (typeof second === "string") {
                return 1;
            }
            const firstMatch = first.exec(path);
            const secondMatch = second.exec(path);
            if (!firstMatch) {
                return -1;
            }
            if (!secondMatch) {
                return 1;
            }
            // Compute how many characters were NOT part of a capture group
            const firstLength = firstMatch[0].length - firstMatch.slice(1).reduce((acc, cur) => acc + cur.length, 0);
            const secondLength = secondMatch[0].length - secondMatch.slice(1).reduce((acc, cur) => acc + cur.length, 0);
            // Prefer the maximum number of non-captured characters
            return secondLength - firstLength;
        });
        return matchingHandlers.length ? matchingHandlers[0] : null;
    }
    attachRestHandlers() {
        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&");
        }
        for (const op of this.apiConfig.ast.operations) {
            for (const ann of op.annotations) {
                if (!(ann instanceof parser_1.RestAnnotation)) {
                    continue;
                }
                if (!this.hasSwagger) {
                    (0, swagger_1.setupSwagger)(this);
                    this.hasSwagger = true;
                }
                const pathFragments = ann.path.split(/\{\w+\}/u);
                let pathRegex = "^";
                for (let i = 0; i < pathFragments.length; ++i) {
                    if (i > 0) {
                        pathRegex += "([^/]+?)";
                    }
                    pathRegex += escapeRegExp(pathFragments[i]);
                }
                pathRegex += "/?$";
                for (const header of ann.headers.keys()) {
                    this.addHeader("Access-Control-Allow-Headers", header.toLowerCase());
                }
                // eslint-disable-next-line @typescript-eslint/no-misused-promises
                this.addHttpHandler(ann.method, new RegExp(pathRegex, "u"), async (req, res, body) => {
                    var _a, _b, _c, _d, _e, _f, _g;
                    try {
                        const args = {};
                        const files = [];
                        const { pathname, query } = (0, url_1.parse)((_a = req.url) !== null && _a !== void 0 ? _a : "");
                        const match = pathname === null || pathname === void 0 ? void 0 : pathname.match(pathRegex);
                        if (!match) {
                            res.statusCode = 404;
                            return;
                        }
                        const simpleArgs = new Map();
                        for (let i = 0; i < ann.pathVariables.length; ++i) {
                            const argName = ann.pathVariables[i];
                            const argValue = match[i + 1];
                            simpleArgs.set(argName, argValue);
                        }
                        const parsedQuery = query ? (0, querystring_1.parse)(query) : {};
                        for (const argName of ann.queryVariables) {
                            const argValue = (_b = parsedQuery[argName]) !== null && _b !== void 0 ? _b : null;
                            if (argValue === null) {
                                continue;
                            }
                            simpleArgs.set(argName, Array.isArray(argValue) ? argValue.join("") : argValue);
                        }
                        for (const [headerName, argName] of ann.headers) {
                            const argValue = (_c = req.headers[headerName.toLowerCase()]) !== null && _c !== void 0 ? _c : null;
                            if (argValue === null) {
                                continue;
                            }
                            simpleArgs.set(argName, Array.isArray(argValue) ? argValue.join("") : argValue);
                        }
                        if (!ann.bodyVariable && ((_d = req.headers["content-type"]) === null || _d === void 0 ? void 0 : _d.match(/^application\/x-www-form-urlencoded/iu))) {
                            const parsedBody = (0, querystring_1.parse)(body.toString());
                            for (const argName of ann.queryVariables) {
                                const argValue = (_e = parsedBody[argName]) !== null && _e !== void 0 ? _e : null;
                                if (argValue === null) {
                                    continue;
                                }
                                simpleArgs.set(argName, Array.isArray(argValue) ? argValue.join("") : argValue);
                            }
                        }
                        else if (!ann.bodyVariable && ((_f = req.headers["content-type"]) === null || _f === void 0 ? void 0 : _f.match(/^multipart\/form-data/iu))) {
                            const busboy = (0, busboy_1.default)({ headers: req.headers });
                            const filePromises = [];
                            busboy.on("field", (field, value) => {
                                if (ann.queryVariables.includes(field)) {
                                    simpleArgs.set(field, `${value}`);
                                }
                            });
                            busboy.on("file", (_field, stream, info) => {
                                const tempName = (0, crypto_1.randomBytes)(32).toString("hex");
                                const writeStream = (0, fs_1.createWriteStream)(tempName);
                                filePromises.push(new Promise((resolve, reject) => {
                                    writeStream.on("error", reject);
                                    writeStream.on("close", () => {
                                        const contents = (0, fs_1.createReadStream)(tempName);
                                        files.push({ contents, name: info.filename });
                                        contents.on("open", () => {
                                            (0, fs_1.unlink)(tempName, err => {
                                                if (err) {
                                                    reject(err);
                                                }
                                                else {
                                                    resolve();
                                                }
                                            });
                                        });
                                    });
                                    writeStream.on("open", () => {
                                        stream.pipe(writeStream);
                                    });
                                }));
                            });
                            await new Promise((resolve, reject) => {
                                busboy.on("finish", resolve);
                                busboy.on("error", reject);
                                busboy.write(body);
                            });
                            await Promise.all(filePromises);
                        }
                        else if (ann.bodyVariable) {
                            const argName = ann.bodyVariable;
                            const arg = op.args.find(x => x.name === argName);
                            if (/application\/json/iu.test((_g = req.headers["content-type"]) !== null && _g !== void 0 ? _g : "")) {
                                args[argName] = JSON.parse(body.toString());
                            }
                            else if (arg) {
                                let { type } = arg;
                                let solved = false;
                                if (type instanceof parser_1.OptionalType) {
                                    if (body.length === 0) {
                                        args[argName] = null;
                                        solved = true;
                                    }
                                    else {
                                        type = type.base;
                                    }
                                }
                                if (!solved) {
                                    if (type instanceof parser_1.BoolPrimitiveType ||
                                        type instanceof parser_1.IntPrimitiveType ||
                                        type instanceof parser_1.UIntPrimitiveType ||
                                        type instanceof parser_1.FloatPrimitiveType ||
                                        type instanceof parser_1.StringPrimitiveType ||
                                        type instanceof parser_1.DatePrimitiveType ||
                                        type instanceof parser_1.DateTimePrimitiveType ||
                                        type instanceof parser_1.MoneyPrimitiveType ||
                                        type instanceof parser_1.DecimalPrimitiveType ||
                                        type instanceof parser_1.BigIntPrimitiveType ||
                                        type instanceof parser_1.CpfPrimitiveType ||
                                        type instanceof parser_1.CnpjPrimitiveType ||
                                        type instanceof parser_1.UuidPrimitiveType ||
                                        type instanceof parser_1.HexPrimitiveType ||
                                        type instanceof parser_1.Base64PrimitiveType) {
                                        simpleArgs.set(argName, body.toString());
                                    }
                                    else if (type instanceof parser_1.BytesPrimitiveType) {
                                        args[argName] = body.toString("base64");
                                    }
                                    else {
                                        args[argName] = JSON.parse(body.toString());
                                    }
                                }
                            }
                        }
                        for (const [argName, argValue] of simpleArgs) {
                            const arg = op.args.find(x => x.name === argName);
                            if (!arg) {
                                continue;
                            }
                            let { type } = arg;
                            if (type instanceof parser_1.OptionalType) {
                                if (argValue === null) {
                                    args[argName] = null;
                                    continue;
                                }
                                else {
                                    type = type.base;
                                }
                            }
                            else if (argValue === null) {
                                args[argName] = argValue;
                                continue;
                            }
                            if (type instanceof parser_1.BoolPrimitiveType) {
                                if (argValue === "true") {
                                    args[argName] = true;
                                }
                                else if (argValue === "false") {
                                    args[argName] = false;
                                }
                                else {
                                    args[argName] = argValue;
                                }
                            }
                            else if (type instanceof parser_1.UIntPrimitiveType || type instanceof parser_1.IntPrimitiveType || type instanceof parser_1.MoneyPrimitiveType) {
                                args[argName] = parseInt(argValue, 10);
                            }
                            else if (type instanceof parser_1.FloatPrimitiveType) {
                                args[argName] = parseFloat(argValue);
                            }
                            else {
                                args[argName] = argValue;
                            }
                        }
                        const ip = (0, request_ip_1.getClientIp)(req);
                        if (!ip) {
                            throw new Error("Couldn't determine client IP");
                        }
                        const request = {
                            args,
                            deviceInfo: {
                                fingerprint: null,
                                id: (0, crypto_1.randomBytes)(16).toString("hex"),
                                language: null,
                                platform: null,
                                timezone: null,
                                type: "rest",
                                version: null,
                            },
                            extra: {},
                            files,
                            headers: req.headers,
                            id: (0, crypto_1.randomBytes)(16).toString("hex"),
                            ip,
                            name: op.name,
                            version: 3,
                        };
                        await this.executeRequest(request, (ctx, reply) => {
                            try {
                                if (ctx) {
                                    for (const [headerKey, headerValue] of ctx.response.headers.entries()) {
                                        res.setHeader(headerKey, headerValue);
                                    }
                                }
                                if (ctx === null || ctx === void 0 ? void 0 : ctx.response.statusCode) {
                                    res.statusCode = ctx.response.statusCode;
                                }
                                if (reply.error) {
                                    const error = this.makeResponseError(reply.error);
                                    if (!(ctx === null || ctx === void 0 ? void 0 : ctx.response.statusCode)) {
                                        const errorNode = this.apiConfig.ast.errors.find(node => node.name === error.type);
                                        const statusAnnotation = errorNode === null || errorNode === void 0 ? void 0 : errorNode.annotations.find(x => x instanceof parser_1.StatusCodeAnnotation);
                                        res.statusCode = statusAnnotation ? statusAnnotation.statusCode : error.type === "Fatal" ? 500 : 400;
                                    }
                                    res.setHeader("content-type", "application/json");
                                    res.write(JSON.stringify(error));
                                    res.end();
                                    return;
                                }
                                if (req.headers.accept === "application/json") {
                                    res.setHeader("content-type", "application/json");
                                    res.write(JSON.stringify(reply.result));
                                    res.end();
                                }
                                else {
                                    let type = op.returnType;
                                    if (type instanceof parser_1.OptionalType) {
                                        if (reply.result === null) {
                                            if (!(ctx === null || ctx === void 0 ? void 0 : ctx.response.statusCode)) {
                                                res.statusCode = ann.method === "GET" ? 404 : 204;
                                            }
                                            res.end();
                                            return;
                                        }
                                        type = type.base;
                                    }
                                    if (type instanceof parser_1.BoolPrimitiveType ||
                                        type instanceof parser_1.IntPrimitiveType ||
                                        type instanceof parser_1.UIntPrimitiveType ||
                                        type instanceof parser_1.FloatPrimitiveType ||
                                        type instanceof parser_1.StringPrimitiveType ||
                                        type instanceof parser_1.DatePrimitiveType ||
                                        type instanceof parser_1.DateTimePrimitiveType ||
                                        type instanceof parser_1.MoneyPrimitiveType ||
                                        type instanceof parser_1.DecimalPrimitiveType ||
                                        type instanceof parser_1.BigIntPrimitiveType ||
                                        type instanceof parser_1.CpfPrimitiveType ||
                                        type instanceof parser_1.CnpjPrimitiveType ||
                                        type instanceof parser_1.UuidPrimitiveType ||
                                        type instanceof parser_1.HexPrimitiveType ||
                                        type instanceof parser_1.Base64PrimitiveType) {
                                        res.setHeader("content-type", "text/plain");
                                        res.write(`${reply.result}`);
                                        res.end();
                                    }
                                    else if (type instanceof parser_1.HtmlPrimitiveType) {
                                        res.setHeader("content-type", "text/html");
                                        res.write(`${reply.result}`);
                                        res.end();
                                    }
                                    else if (type instanceof parser_1.XmlPrimitiveType) {
                                        res.setHeader("content-type", "text/xml");
                                        res.write(`${reply.result}`);
                                        res.end();
                                    }
                                    else if (type instanceof parser_1.BytesPrimitiveType) {
                                        const buffer = Buffer.from(reply.result, "base64");
                                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                                        file_type_1.default.fromBuffer(buffer)
                                            .then(fileType => {
                                            var _a;
                                            res.setHeader("content-type", (_a = fileType === null || fileType === void 0 ? void 0 : fileType.mime) !== null && _a !== void 0 ? _a : "application/octet-stream");
                                        })
                                            .catch(err => {
                                            console.error(err);
                                            res.setHeader("content-type", "application/octet-stream");
                                        })
                                            .then(() => {
                                            res.write(buffer);
                                            res.end();
                                        })
                                            .catch(() => { });
                                    }
                                    else {
                                        res.setHeader("content-type", "application/json");
                                        res.write(JSON.stringify(reply.result));
                                        res.end();
                                    }
                                }
                            }
                            catch (error) {
                                console.error(error);
                                if (!res.headersSent) {
                                    res.statusCode = 500;
                                }
                                res.end();
                            }
                        });
                    }
                    catch (error) {
                        console.error(error);
                        if (!res.headersSent) {
                            res.statusCode = 500;
                        }
                        res.end();
                    }
                });
            }
        }
    }
    async handleRequestWithBody(req, res, body, hrStart) {
        var _a, _b;
        const { pathname, query } = (0, url_1.parse)((_a = req.url) !== null && _a !== void 0 ? _a : "");
        let path = pathname !== null && pathname !== void 0 ? pathname : "";
        if (path.startsWith(this.ignoredUrlPrefix)) {
            path = path.slice(this.ignoredUrlPrefix.length);
        }
        if (!((_b = req.headers["content-type"]) === null || _b === void 0 ? void 0 : _b.match(/application\/sdkgen/iu))) {
            const externalHandler = this.findBestHandler(path, req);
            if (externalHandler) {
                this.log(`HTTP ${req.method} ${path}${query ? `?${query}` : ""}`);
                externalHandler.handler(req, res, body);
                return;
            }
        }
        res.setHeader("Content-Type", "application/json; charset=utf-8");
        if (req.method === "HEAD") {
            res.writeHead(200);
            res.end();
            return;
        }
        if (req.method === "GET") {
            if (path !== "/") {
                res.writeHead(404);
                res.end();
                return;
            }
            let ok = true;
            try {
                for (const healthCheck of this.healthChecks) {
                    if (!ok) {
                        break;
                    }
                    ok = await healthCheck();
                }
            }
            catch (e) {
                ok = false;
            }
            res.statusCode = ok ? 200 : 500;
            res.write(JSON.stringify({ ok }));
            res.end();
            return;
        }
        if (req.method !== "POST") {
            res.writeHead(400);
            res.end();
            return;
        }
        const clientIp = (0, request_ip_1.getClientIp)(req);
        if (!clientIp) {
            this.writeReply(res, null, {
                error: new error_1.Fatal("Couldn't determine client IP"),
            }, hrStart);
            return;
        }
        const request = this.parseRequest(req, body.toString(), clientIp);
        if (!request) {
            this.writeReply(res, null, {
                error: new error_1.Fatal("Couldn't parse request"),
            }, hrStart);
            return;
        }
        await this.executeRequest(request, (ctx, reply) => this.writeReply(res, ctx, reply, hrStart));
    }
    async executeRequest(request, writeReply) {
        const ctx = Object.assign(Object.assign({}, this.extraContext), { request, response: {
                headers: new Map(),
            } });
        writeReply(ctx, await (0, execute_1.executeRequest)(ctx, this.apiConfig));
    }
    parseRequest(req, body, ip) {
        switch (this.identifyRequestVersion(req, body)) {
            case 1:
                return this.parseRequestV1(req, body, ip);
            case 2:
                return this.parseRequestV2(req, body, ip);
            case 3:
                return this.parseRequestV3(req, body, ip);
            default:
                throw new Error("Failed to understand request");
        }
    }
    identifyRequestVersion(_req, body) {
        const parsed = JSON.parse(body);
        if (typeof parsed === "object" && parsed && (0, utils_1.has)(parsed, "version") && typeof parsed.version === "number") {
            return parsed.version;
        }
        else if (typeof parsed === "object" && parsed && (0, utils_1.has)(parsed, "requestId")) {
            return 2;
        }
        else if (typeof parsed === "object" && parsed && (0, utils_1.has)(parsed, "device")) {
            return 1;
        }
        return 3;
    }
    // Old Sdkgen format
    parseRequestV1(req, body, ip) {
        var _a, _b;
        const parsed = (0, encode_decode_1.decode)({
            Request: {
                args: "json",
                device: "RequestDevice",
                id: "string",
                name: "string",
            },
            RequestDevice: {
                fingerprint: "string?",
                id: "string?",
                language: "string?",
                platform: "json?",
                timezone: "string?",
                type: "string?",
                version: "string?",
            },
        }, "root", "Request", JSON.parse(body));
        const deviceId = (_a = parsed.device.id) !== null && _a !== void 0 ? _a : (0, crypto_1.randomBytes)(20).toString("hex");
        if (!parsed.args || Array.isArray(parsed.args) || typeof parsed.args !== "object") {
            throw new Error("Expected 'args' to be an object");
        }
        return {
            args: parsed.args,
            deviceInfo: {
                fingerprint: parsed.device.fingerprint,
                id: deviceId,
                language: parsed.device.language,
                platform: parsed.device.platform,
                timezone: parsed.device.timezone,
                type: (_b = parsed.device.type) !== null && _b !== void 0 ? _b : (typeof parsed.device.platform === "string" ? parsed.device.platform : ""),
                version: parsed.device.version,
            },
            extra: {},
            files: [],
            headers: req.headers,
            id: `${deviceId}-${parsed.id}`,
            ip,
            name: parsed.name,
            version: 1,
        };
    }
    // Maxima sdkgen format
    parseRequestV2(req, body, ip) {
        var _a, _b;
        const parsed = (0, encode_decode_1.decode)({
            Request: {
                args: "json",
                deviceFingerprint: "string?",
                deviceId: "string",
                info: "RequestInfo",
                name: "string",
                partnerId: "string?",
                requestId: "string?",
                sessionId: "string?",
            },
            RequestInfo: {
                browserUserAgent: "string?",
                language: "string",
                type: "string",
            },
        }, "root", "Request", JSON.parse(body));
        if (!parsed.args || Array.isArray(parsed.args) || typeof parsed.args !== "object") {
            throw new Error("Expected 'args' to be an object");
        }
        return {
            args: parsed.args,
            deviceInfo: {
                fingerprint: parsed.deviceFingerprint,
                id: parsed.deviceId,
                language: parsed.info.language,
                platform: {
                    browserUserAgent: (_a = parsed.info.browserUserAgent) !== null && _a !== void 0 ? _a : null,
                },
                timezone: null,
                type: parsed.info.type,
                version: "",
            },
            extra: {
                partnerId: parsed.partnerId,
                sessionId: parsed.sessionId,
            },
            files: [],
            headers: req.headers,
            id: `${parsed.deviceId}-${(_b = parsed.requestId) !== null && _b !== void 0 ? _b : (0, crypto_1.randomBytes)(16).toString("hex")}`,
            ip,
            name: parsed.name,
            version: 2,
        };
    }
    // New sdkgen format
    parseRequestV3(req, body, ip) {
        var _a, _b, _c, _d;
        const parsed = (0, encode_decode_1.decode)({
            DeviceInfo: {
                fingerprint: "string?",
                id: "string?",
                language: "string?",
                platform: "json?",
                timezone: "string?",
                type: "string?",
                version: "string?",
            },
            Request: {
                args: "json",
                deviceInfo: "DeviceInfo?",
                extra: "json?",
                name: "string",
                requestId: "string?",
            },
        }, "root", "Request", JSON.parse(body));
        const deviceInfo = (_a = parsed.deviceInfo) !== null && _a !== void 0 ? _a : {
            fingerprint: null,
            id: null,
            language: null,
            platform: null,
            timezone: null,
            type: null,
            version: null,
        };
        const deviceId = (_b = deviceInfo.id) !== null && _b !== void 0 ? _b : (0, crypto_1.randomBytes)(16).toString("hex");
        if (!parsed.args || Array.isArray(parsed.args) || typeof parsed.args !== "object") {
            throw new Error("Expected 'args' to be an object");
        }
        return {
            args: parsed.args,
            deviceInfo: {
                fingerprint: deviceInfo.fingerprint,
                id: deviceId,
                language: deviceInfo.language,
                platform: typeof deviceInfo.platform === "object" ? Object.assign({}, deviceInfo.platform) : {},
                timezone: deviceInfo.timezone,
                type: (_c = deviceInfo.type) !== null && _c !== void 0 ? _c : "api",
                version: deviceInfo.version,
            },
            extra: typeof parsed.extra === "object" ? Object.assign({}, parsed.extra) : {},
            files: [],
            headers: req.headers,
            id: `${deviceId}-${(_d = parsed.requestId) !== null && _d !== void 0 ? _d : (0, crypto_1.randomBytes)(16).toString("hex")}`,
            ip,
            name: parsed.name,
            version: 3,
        };
    }
    makeResponseError(err) {
        let type = "Fatal";
        if (typeof err === "object" && err !== null && (0, utils_1.has)(err, "type") && typeof err.type === "string") {
            ({ type } = err);
        }
        let message;
        if (typeof err === "object" && err !== null && (0, utils_1.has)(err, "message") && typeof err.message === "string") {
            ({ message } = err);
        }
        else if (err instanceof Error) {
            message = err.toString();
        }
        else if (typeof err === "object") {
            message = JSON.stringify(err);
        }
        else {
            message = `${err}`;
        }
        let data;
        if (typeof err === "object" && err !== null && (0, utils_1.has)(err, "data")) {
            ({ data } = err);
        }
        const error = this.apiConfig.ast.errors.find(x => x.name === type);
        if (error) {
            if (!(error.dataType instanceof parser_1.VoidPrimitiveType)) {
                try {
                    data = (0, encode_decode_1.encode)(this.apiConfig.astJson.typeTable, `error.${type}`, error.dataType.name, data);
                }
                catch (encodeError) {
                    message = `Failed to encode error ${type} because: ${encodeError}. Original message: ${message}`;
                    type = "Fatal";
                }
            }
        }
        else {
            type = "Fatal";
        }
        return { data, message, type };
    }
    writeReply(res, ctx, reply, hrStart) {
        var _a, _b;
        if (!ctx) {
            res.statusCode = 500;
            res.write(JSON.stringify({
                error: this.makeResponseError((_a = reply.error) !== null && _a !== void 0 ? _a : new error_1.Fatal("Response without context")),
            }));
            res.end();
            return;
        }
        const deltaTime = process.hrtime(hrStart);
        const duration = deltaTime[0] + deltaTime[1] * 1e-9;
        if (reply.error) {
            console.error(reply.error);
        }
        this.log(`${ctx.request.id} [${duration.toFixed(6)}s] ${ctx.request.name}() -> ${reply.error ? this.makeResponseError(reply.error).type : "OK"}`);
        if (ctx.response.statusCode) {
            res.statusCode = ctx.response.statusCode;
        }
        for (const [headerKey, headerValue] of ctx.response.headers.entries()) {
            res.setHeader(headerKey, headerValue);
        }
        switch (ctx.request.version) {
            case 1: {
                const response = {
                    deviceId: ctx.request.deviceInfo.id,
                    duration,
                    error: reply.error ? this.makeResponseError(reply.error) : null,
                    host: (0, os_1.hostname)(),
                    id: ctx.request.id,
                    ok: !reply.error,
                    result: reply.error ? null : reply.result,
                };
                if (response.error && !ctx.response.statusCode) {
                    res.statusCode = this.makeResponseError(response.error).type === "Fatal" ? 500 : 400;
                }
                res.write(JSON.stringify(response));
                res.end();
                break;
            }
            case 2: {
                const response = {
                    deviceId: ctx.request.deviceInfo.id,
                    error: reply.error ? this.makeResponseError(reply.error) : null,
                    ok: !reply.error,
                    requestId: ctx.request.id,
                    result: reply.error ? null : reply.result,
                    sessionId: ctx.request.extra.sessionId,
                };
                if (response.error && !ctx.response.statusCode) {
                    res.statusCode = this.makeResponseError(response.error).type === "Fatal" ? 500 : 400;
                }
                res.write(JSON.stringify(response));
                res.end();
                break;
            }
            case 3: {
                const response = {
                    duration,
                    error: reply.error ? this.makeResponseError(reply.error) : null,
                    host: (0, os_1.hostname)(),
                    result: reply.error ? null : reply.result,
                };
                if (response.error && !ctx.response.statusCode) {
                    res.statusCode = this.makeResponseError(response.error).type === "Fatal" ? 500 : 400;
                }
                res.setHeader("x-request-id", ctx.request.id);
                res.write(JSON.stringify(response));
                res.end();
                break;
            }
            default: {
                res.statusCode = 500;
                res.write(JSON.stringify({
                    error: this.makeResponseError((_b = reply.error) !== null && _b !== void 0 ? _b : new error_1.Fatal("Unknown request version")),
                }));
                res.end();
                return;
            }
        }
    }
}
exports.SdkgenHttpServer = SdkgenHttpServer;
