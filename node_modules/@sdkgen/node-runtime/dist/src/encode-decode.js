"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
const CNPJ = __importStar(require("@fnando/cnpj"));
const CPF = __importStar(require("@fnando/cpf"));
const decimal_js_1 = require("decimal.js");
const simpleStringTypes = ["string", "email", "html", "xml"];
const simpleTypes = ["json", "bool", "url", "int", "uint", "float", "money", "hex", "uuid", "base64", "void", ...simpleStringTypes];
class ParseError extends Error {
    constructor(path, type, value) {
        let str;
        try {
            str = JSON.stringify(value);
        }
        catch (err) {
            str = String(value);
        }
        super(`Invalid type at '${path}', expected ${String(type)}, got ${str}`);
    }
}
function simpleEncodeDecode(path, type, value) {
    if (type === "json") {
        if (value === null || value === undefined) {
            return null;
        }
        return JSON.parse(JSON.stringify(value));
    }
    else if (type === "bool") {
        if (typeof value !== "boolean") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (simpleStringTypes.includes(type)) {
        if (typeof value !== "string") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "hex") {
        if (typeof value !== "string" || !/^(?:[A-Fa-f0-9]{2})*$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        return value.toLowerCase();
    }
    else if (type === "uuid") {
        if (typeof value !== "string" || !/^[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        return value.toLowerCase();
    }
    else if (type === "base64") {
        if (typeof value !== "string" || Buffer.from(value, "base64").toString("base64") !== value) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "int") {
        if (typeof value !== "number" || (value | 0) !== value) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "uint") {
        if (typeof value !== "number" || (value | 0) !== value || value < 0) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "float") {
        if (typeof value !== "number") {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "money") {
        if (typeof value !== "number" || !Number.isInteger(value)) {
            throw new ParseError(path, type, value);
        }
        return value;
    }
    else if (type === "url") {
        let url;
        if (typeof value === "string") {
            try {
                url = new URL(value);
            }
            catch (e) {
                // ignore
            }
        }
        if (!url) {
            throw new ParseError(path, type, value);
        }
        return url.toString();
    }
    else if (type === "void") {
        return null;
    }
    throw new Error(`Unknown type '${type}' at '${path}'`);
}
function encode(typeTable, path, type, value) {
    if (typeof type === "string" && !type.endsWith("?") && type !== "void" && (value === null || value === undefined)) {
        throw new Error(`Invalid type at '${path}', cannot be null`);
    }
    else if (Array.isArray(type)) {
        if (type.every(tag => typeof tag === "string")) {
            for (const tag of type) {
                if (tag === value) {
                    return tag;
                }
            }
        }
        else if (typeof value === "object" && value && "tag" in value) {
            const _a = value, { tag: tagValue } = _a, restValue = __rest(_a, ["tag"]);
            for (const entry of type) {
                if (typeof entry === "string") {
                    if (entry === tagValue) {
                        return entry;
                    }
                }
                else {
                    const [tag, valueType] = entry;
                    if (tag === tagValue) {
                        const encodedValues = encode(typeTable, `${path}.${tag}`, valueType, restValue);
                        // eslint-disable-next-line max-depth
                        if (Object.values(encodedValues).every(v => v === null)) {
                            return tag;
                        }
                        return [tag, encodedValues];
                    }
                }
            }
        }
        throw new ParseError(path, type, value);
    }
    else if (typeof type === "object") {
        if (typeof value !== "object") {
            throw new ParseError(path, type, value);
        }
        const obj = {};
        for (const key of Object.keys(type)) {
            obj[key] = encode(typeTable, `${path}.${key}`, type[key], value[key]);
        }
        return obj;
    }
    else if (typeof type === "string" && type.endsWith("?")) {
        if (value === null || value === undefined) {
            return null;
        }
        return encode(typeTable, path, type.slice(0, type.length - 1), value);
    }
    else if (typeof type === "string" && type.endsWith("[]")) {
        if (!Array.isArray(value)) {
            throw new ParseError(path, type, value);
        }
        return value.map((entry, index) => encode(typeTable, `${path}[${index}]`, type.slice(0, type.length - 2), entry));
    }
    else if (typeof type === "string" && simpleTypes.includes(type)) {
        return simpleEncodeDecode(path, type, value);
    }
    else if (type === "bytes") {
        if (!(value instanceof Buffer)) {
            throw new ParseError(path, type, value);
        }
        return value.toString("base64");
    }
    else if (type === "bigint") {
        if (!(typeof value === "bigint")) {
            throw new ParseError(path, type, value);
        }
        return value.toString();
    }
    else if (type === "cpf") {
        if (typeof value !== "string" || !CPF.isValid(value)) {
            throw new ParseError(path, type, value);
        }
        return CPF.strip(value);
    }
    else if (type === "cnpj") {
        if (typeof value !== "string" || !CNPJ.isValid(value)) {
            throw new ParseError(path, type, value);
        }
        return CNPJ.strip(value);
    }
    else if (type === "date") {
        if (!(value instanceof Date && !isNaN(value.getTime())) && !(typeof value === "string" && /^[0-9]{4}-[01][0-9]-[0123][0-9]$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        const dateValue = value instanceof Date ? value : new Date(value);
        return `${dateValue.getFullYear().toString().padStart(4, "0")}-${(dateValue.getMonth() + 1).toString().padStart(2, "0")}-${dateValue
            .getDate()
            .toString()
            .padStart(2, "0")}`;
    }
    else if (type === "datetime") {
        if (!(value instanceof Date && !isNaN(value.getTime())) &&
            !(typeof value === "string" &&
                /^[0-9]{4}-[01][0-9]-[0123][0-9]T[012][0-9]:[0123456][0-9]:[0123456][0-9](?:\.[0-9]{1,6})?(?:Z|[+-][012][0-9]:[0123456][0-9])?$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        return (typeof value === "string" ? new Date(value) : value).toISOString().replace("Z", "");
    }
    else if (type === "decimal") {
        if (typeof value !== "number" && (typeof value !== "string" || !/^-?[0-9]+(?:\.[0-9]+)?$/u.test(value)) && !decimal_js_1.Decimal.isDecimal(value)) {
            throw new ParseError(path, type, value);
        }
        return new decimal_js_1.Decimal(value).toString();
    }
    else {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        const resolved = typeTable[type];
        if (resolved) {
            return encode(typeTable, path, resolved, value);
        }
        throw new Error(`Unknown type '${String(type)}' at '${path}'`);
    }
}
exports.encode = encode;
function decode(typeTable, path, type, value) {
    if (typeof type === "string" && !type.endsWith("?") && type !== "void" && (value === null || value === undefined)) {
        throw new Error(`Invalid type at '${path}', cannot be null`);
    }
    else if (Array.isArray(type)) {
        if (type.every(tag => typeof tag === "string")) {
            for (const tag of type) {
                if (tag === value) {
                    return tag;
                }
            }
        }
        else {
            for (const entry of type) {
                if (typeof entry === "string") {
                    if (entry === value) {
                        return { tag: entry };
                    }
                }
                else {
                    const [tag, valueType] = entry;
                    if (tag === value) {
                        const decodedValues = decode(typeTable, `${path}.${tag}`, valueType, {});
                        return Object.assign(Object.assign({}, decodedValues), { tag });
                    }
                    else if (Array.isArray(value) && value.length === 2 && tag === value[0]) {
                        const decodedValues = decode(typeTable, `${path}.${tag}`, valueType, value[1]);
                        return Object.assign(Object.assign({}, decodedValues), { tag });
                    }
                }
            }
        }
        throw new ParseError(path, type, value);
    }
    else if (typeof type === "object") {
        if (typeof value !== "object") {
            throw new ParseError(path, type, value);
        }
        const obj = {};
        for (const key of Object.keys(type)) {
            obj[key] = decode(typeTable, `${path}.${key}`, type[key], value[key]);
        }
        return obj;
    }
    else if (typeof type === "string" && type.endsWith("?")) {
        if (value === null || value === undefined) {
            return null;
        }
        return decode(typeTable, path, type.slice(0, type.length - 1), value);
    }
    else if (typeof type === "string" && type.endsWith("[]")) {
        if (!Array.isArray(value)) {
            throw new ParseError(path, type, value);
        }
        return value.map((entry, index) => decode(typeTable, `${path}[${index}]`, type.slice(0, type.length - 2), entry));
    }
    else if (typeof type === "string" && simpleTypes.includes(type)) {
        return simpleEncodeDecode(path, type, value);
    }
    else if (type === "bytes") {
        if (typeof value !== "string") {
            throw new ParseError(path, `${String(type)} (base 64)`, value);
        }
        const buffer = Buffer.from(value, "base64");
        if (buffer.toString("base64") !== value) {
            throw new ParseError(path, `${String(type)} (base 64)`, value);
        }
        return buffer;
    }
    else if (type === "bigint") {
        if (typeof value !== "number" && (typeof value !== "string" || !/^-?[0-9]+$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        return BigInt(value);
    }
    else if (type === "cpf") {
        if (typeof value !== "string" || !CPF.isValid(value)) {
            throw new ParseError(path, type, value);
        }
        return CPF.format(value);
    }
    else if (type === "cnpj") {
        if (typeof value !== "string" || !CNPJ.isValid(value)) {
            throw new ParseError(path, type, value);
        }
        return CNPJ.format(value);
    }
    else if (type === "date") {
        if (typeof value !== "string" || !/^[0-9]{4}-[01][0-9]-[0123][0-9]$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        const day = parseInt(value.split("-")[2], 10);
        const month = parseInt(value.split("-")[1], 10) - 1;
        const year = parseInt(value.split("-")[0], 10);
        const date = new Date(year, month, day);
        if (date.getFullYear() !== year || date.getMonth() !== month || date.getDate() !== day) {
            throw new ParseError(path, type, value);
        }
        return date;
    }
    else if (type === "datetime") {
        if (typeof value !== "string" || !/^[0-9]{4}-[01][0-9]-[0123][0-9]T[012][0-9]:[0123456][0-9]:[0123456][0-9](?:\.[0-9]{1,6})?Z?$/u.test(value)) {
            throw new ParseError(path, type, value);
        }
        return new Date(`${value.endsWith("Z") ? value : value.concat("Z")}`);
    }
    else if (type === "decimal") {
        if (typeof value !== "number" && (typeof value !== "string" || !/^-?[0-9]+(?:\.[0-9]+)?$/u.test(value))) {
            throw new ParseError(path, type, value);
        }
        return new decimal_js_1.Decimal(value);
    }
    else {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        const resolved = typeTable[type];
        if (resolved) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return decode(typeTable, path, resolved, value);
        }
        throw new Error(`Unknown type '${String(type)}' at '${path}'`);
    }
}
exports.decode = decode;
