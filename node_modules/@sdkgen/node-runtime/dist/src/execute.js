"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeRequest = void 0;
const parser_1 = require("@sdkgen/parser");
const encode_decode_1 = require("./encode-decode");
const error_1 = require("./error");
const utils_1 = require("./utils");
async function executeRequest(ctx, apiConfig) {
    // eslint-disable-next-line func-style
    let next = async () => {
        try {
            const functionDescription = apiConfig.astJson.functionTable[ctx.request.name];
            const functionImplementation = apiConfig.fn[ctx.request.name];
            if (!functionDescription || !functionImplementation) {
                throw new error_1.Fatal(`Function does not exist: ${ctx.request.name}`);
            }
            const args = (0, encode_decode_1.decode)(apiConfig.astJson.typeTable, `${ctx.request.name}.args`, functionDescription.args, ctx.request.args);
            const ret = (await functionImplementation(ctx, args));
            const encodedRet = (0, encode_decode_1.encode)(apiConfig.astJson.typeTable, `${ctx.request.name}.ret`, functionDescription.ret, ret);
            return { result: encodedRet };
        }
        catch (error) {
            return { error };
        }
    };
    for (let i = apiConfig.middlewares.length - 1; i >= 0; --i) {
        const middleware = apiConfig.middlewares[i];
        const previousNext = next;
        next = async () => {
            try {
                return await middleware(ctx, previousNext);
            }
            catch (error) {
                return { error };
            }
        };
    }
    const reply = await next();
    // If errors, check if the error type is one of the @throws annotation. If it isn't, change to Fatal
    if (reply.error) {
        const functionAst = apiConfig.ast.operations.find(op => op.name === ctx.request.name);
        if (functionAst) {
            const allowedErrors = functionAst.annotations.filter(ann => ann instanceof parser_1.ThrowsAnnotation).map(ann => ann.error);
            if (typeof reply.error !== "object" ||
                reply.error === null ||
                !(0, utils_1.has)(reply.error, "type") ||
                typeof reply.error.type !== "string" ||
                (allowedErrors.length > 0 && !allowedErrors.includes(reply.error.type)) ||
                !apiConfig.astJson.errors.map(error => (typeof error === "string" ? error : error[0])).includes(reply.error.type)) {
                Object.defineProperty(reply.error, "type", { value: "Fatal" });
            }
        }
    }
    return reply;
}
exports.executeRequest = executeRequest;
