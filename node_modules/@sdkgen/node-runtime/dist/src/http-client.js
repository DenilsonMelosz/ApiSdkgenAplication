"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkgenHttpClient = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable prefer-promise-reject-errors */
const crypto_1 = require("crypto");
const http_1 = require("http");
const https_1 = require("https");
const os_1 = require("os");
const url_1 = require("url");
const encode_decode_1 = require("./encode-decode");
const utils_1 = require("./utils");
class SdkgenHttpClient {
    constructor(baseUrl, astJson, errClasses) {
        this.astJson = astJson;
        this.errClasses = errClasses;
        this.extra = new Map();
        this.baseUrl = new url_1.URL(baseUrl);
    }
    async makeRequest(ctx, functionName, args) {
        var _a, _b, _c, _d;
        const func = this.astJson.functionTable[functionName];
        if (!func) {
            throw new Error(`Unknown function ${functionName}`);
        }
        const extra = {};
        for (const [key, value] of this.extra) {
            extra[key] = value;
        }
        const requestBody = JSON.stringify({
            args: (0, encode_decode_1.encode)(this.astJson.typeTable, `${functionName}.args`, func.args, args),
            deviceInfo: (_b = (_a = ctx === null || ctx === void 0 ? void 0 : ctx.request) === null || _a === void 0 ? void 0 : _a.deviceInfo) !== null && _b !== void 0 ? _b : { id: (0, os_1.hostname)(), type: "node" },
            extra: Object.assign(Object.assign({}, extra), (_c = ctx === null || ctx === void 0 ? void 0 : ctx.request) === null || _c === void 0 ? void 0 : _c.extra),
            name: functionName,
            requestId: ((_d = ctx === null || ctx === void 0 ? void 0 : ctx.request) === null || _d === void 0 ? void 0 : _d.id) ? ctx.request.id + (0, crypto_1.randomBytes)(6).toString("hex") : (0, crypto_1.randomBytes)(16).toString("hex"),
            version: 3,
        });
        const options = {
            hostname: this.baseUrl.hostname,
            method: "POST",
            path: this.baseUrl.pathname,
            port: this.baseUrl.port,
            headers: {
                "content-type": "application/sdkgen",
            },
        };
        const encodedRet = await new Promise((resolve, reject) => {
            const req = (this.baseUrl.protocol === "http:" ? http_1.request : https_1.request)(options, res => {
                let data = "";
                res.on("data", chunk => {
                    data += chunk;
                });
                res.on("end", () => {
                    try {
                        const response = JSON.parse(data);
                        if ((0, utils_1.has)(response, "error") && response.error) {
                            reject(response.error);
                        }
                        else {
                            resolve((0, utils_1.has)(response, "result") ? response.result : null);
                        }
                    }
                    catch (error) {
                        reject({ message: `${error}`, type: "Fatal" });
                    }
                });
                res.on("error", error => {
                    reject({ message: `${error}`, type: "Fatal" });
                });
                res.on("aborted", () => {
                    reject({ message: "Request aborted", type: "Fatal" });
                });
            });
            req.on("error", error => {
                reject({ message: `${error}`, type: "Fatal" });
            });
            req.write(requestBody);
            req.end();
        }).catch((error) => {
            var _a;
            if ((0, utils_1.has)(error, "type") && (0, utils_1.has)(error, "message") && typeof error.type === "string" && typeof error.message === "string") {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const errClass = (_a = this.errClasses[error.type]) !== null && _a !== void 0 ? _a : this.errClasses.Fatal;
                const errType = errClass.name;
                const errorJson = this.astJson.errors.find(err => (Array.isArray(err) ? err[0] === errType : err === errType));
                let newError;
                if (errorJson && Array.isArray(errorJson) && (0, utils_1.has)(error, "data")) {
                    newError = new errClass(error.message, (0, encode_decode_1.decode)(this.astJson.typeTable, `${errClass.name}.data`, errorJson[1], error.data));
                }
                else {
                    newError = new errClass(error.message, undefined);
                }
                if (!newError.type) {
                    newError.type = errType;
                }
                throw newError;
            }
            else {
                throw error;
            }
        });
        return (0, encode_decode_1.decode)(this.astJson.typeTable, `${functionName}.ret`, func.ret, encodedRet);
    }
}
exports.SdkgenHttpClient = SdkgenHttpClient;
