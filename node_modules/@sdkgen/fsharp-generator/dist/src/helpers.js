"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateEnum = exports.generateStruct = exports.encodeType = exports.decodeType = exports.generateTypeName = exports.capitalize = exports.ident = void 0;
const parser_1 = require("@sdkgen/parser");
const reservedWords = [
    "abstract",
    "as",
    "base",
    "bool",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "checked",
    "class",
    "const",
    "continue",
    "decimal",
    "default",
    "delegate",
    "do",
    "double",
    "else",
    "enum",
    "event",
    "explicit",
    "extern",
    "false",
    "finally",
    "fixed",
    "float",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "int",
    "interface",
    "internal",
    "is",
    "lock",
    "long",
    "namespace",
    "new",
    "null",
    "object",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "ref",
    "return",
    "sbyte",
    "sealed",
    "short",
    "sizeof",
    "stackalloc",
    "static",
    "string",
    "struct",
    "switch",
    "this",
    "throw",
    "true",
    "try",
    "typeof",
    "uint",
    "ulong",
    "unchecked",
    "unsafe",
    "ushort",
    "using",
    "using",
    "static",
    "virtual",
    "void",
    "volatile",
    "while",
    "type",
    "end",
    "id",
];
const typesWithNativeNullable = [
    parser_1.StringPrimitiveType,
    parser_1.HtmlPrimitiveType,
    parser_1.CpfPrimitiveType,
    parser_1.CnpjPrimitiveType,
    parser_1.BytesPrimitiveType,
    parser_1.EmailPrimitiveType,
    parser_1.UrlPrimitiveType,
    parser_1.UuidPrimitiveType,
    parser_1.HexPrimitiveType,
    parser_1.Base64PrimitiveType,
    parser_1.XmlPrimitiveType,
    parser_1.StructType,
    parser_1.ArrayType,
];
const needsTempVarForNullable = [
    parser_1.BigIntPrimitiveType,
    parser_1.DatePrimitiveType,
    parser_1.DateTimePrimitiveType,
    parser_1.FloatPrimitiveType,
    parser_1.IntPrimitiveType,
    parser_1.MoneyPrimitiveType,
    parser_1.UIntPrimitiveType,
    parser_1.ArrayType,
];
function ident(name) {
    return reservedWords.includes(name) ? `${name}'` : name;
}
exports.ident = ident;
function capitalize(name) {
    return name[0].toUpperCase() + name.slice(1);
}
exports.capitalize = capitalize;
function generateTypeName(type) {
    switch (type.constructor) {
        case parser_1.StringPrimitiveType:
            return "string";
        case parser_1.IntPrimitiveType:
            return "int";
        case parser_1.UIntPrimitiveType:
            return "uint";
        case parser_1.FloatPrimitiveType:
            return "double";
        case parser_1.BigIntPrimitiveType:
            return "bigint";
        case parser_1.DatePrimitiveType:
        case parser_1.DateTimePrimitiveType:
            return "DateTime";
        case parser_1.BoolPrimitiveType:
            return "bool";
        case parser_1.BytesPrimitiveType:
            return "byte[]";
        case parser_1.MoneyPrimitiveType:
            return "decimal";
        case parser_1.UuidPrimitiveType:
            return "Guid";
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
            return "string";
        case parser_1.VoidPrimitiveType:
            return "void";
        case parser_1.JsonPrimitiveType:
            return "JsonElement";
        case parser_1.OptionalType:
            return `${generateTypeName(type.base)} option`;
        case parser_1.ArrayType:
            return `${generateTypeName(type.base)} list`;
        case parser_1.StructType:
            return type.name;
        case parser_1.EnumType:
            return type.name;
        case parser_1.TypeReference:
            return generateTypeName(type.type);
        default:
            throw new Error(`BUG: generateTypeName with ${type.constructor.name}`);
    }
}
exports.generateTypeName = generateTypeName;
function decodeType(type, jsonElementVar, path, targetVar, suffix = 1, maybeNull = true) {
    switch (type.constructor) {
        case parser_1.IntPrimitiveType: {
            return `
              decodeInt32 ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.UIntPrimitiveType: {
            return `
              decodeUInt32 ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.MoneyPrimitiveType: {
            return `
                (decodeMoney ${jsonElementVar} ${path}) / 100m
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.FloatPrimitiveType: {
            return `
                decodeFloat ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.BigIntPrimitiveType: {
            return `
                decodeBigInt ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.StringPrimitiveType: {
            return `
                decodeString ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.HtmlPrimitiveType: {
            // TODO: validate HTML
            return `
                decodeHtml ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.CpfPrimitiveType: {
            // TODO: validate CPF
            return `
                decodeCpf ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.CnpjPrimitiveType: {
            // TODO: validate CNPJ
            return `
                decodeCnpj ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.EmailPrimitiveType: {
            // TODO: validate Email
            return `
                decodeEmail ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.UrlPrimitiveType: {
            // TODO: validate URL
            return `
                decodeUrl ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.UuidPrimitiveType: {
            // TODO: validate UUID
            return `
                decodeUuid ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.HexPrimitiveType: {
            // TODO: validate Hex
            return `
                decodeHex ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.Base64PrimitiveType: {
            // TODO: validate Base64
            return `
                decodeBase64 ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.XmlPrimitiveType: {
            // TODO: validate XML
            return `
                decodeXml ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.BoolPrimitiveType: {
            return `
                decodeBool ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.BytesPrimitiveType: {
            return `
                decodeBytes ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.TypeReference:
            return decodeType(type.type, jsonElementVar, path, targetVar, suffix);
        case parser_1.OptionalType:
            if (needsTempVarForNullable.includes(type.base.constructor)) {
                return `match ${jsonElementVar}.ValueKind with
                  | JsonValueKind.Null | JsonValueKind.Undefined -> None
                  | _ ->
                    (${decodeType(type.base, jsonElementVar, path, targetVar, suffix, false).replace(/\n/gu, "\n                    ")}) |> Some
                `
                    .replace(/\n {16}/gu, "\n")
                    .trim();
            }
            if (type.base instanceof parser_1.OptionalType || type.base instanceof parser_1.ArrayType) {
                return `
                (>.>) decodeOptional ${decodeType(type.base, jsonElementVar, path, targetVar, suffix, false)}
            `
                    .replace(/\n {16}/gu, "\n")
                    .trim();
            }
            return `
                decodeOptional ${decodeType(type.base, jsonElementVar, path, targetVar, suffix, false)}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        case parser_1.EnumType:
        case parser_1.StructType:
            return `Decode${type.name} ${jsonElementVar} ${path}`;
        case parser_1.JsonPrimitiveType:
            if (maybeNull) {
                return `
                ${jsonElementVar}
            `
                    .replace(/\n {16}/gu, "\n")
                    .trim();
            }
            return `${targetVar} <- ${jsonElementVar}`;
        case parser_1.DateTimePrimitiveType: {
            return `
                decodeDateTime ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.DatePrimitiveType: {
            return `
                decodeDate ${jsonElementVar} ${path}
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        case parser_1.ArrayType: {
            return `
                match ${jsonElementVar}.ValueKind with
                  | JsonValueKind.Array ->
                    let mutable list_ = List.empty
                    for i1 in 0 .. (${jsonElementVar}.GetArrayLength() - 1) do
                      let item = ${jsonElementVar}.[i1]
                      let partialResult =
                        ${decodeType(type.base, `${jsonElementVar}.[i1]`, `${path.slice(0, -1)}.{i1}"`, targetVar, suffix, false).replace(/\n/gu, "\n                      ")}
                      list_ <- list_ |> List.append [ partialResult ]
                    list_
                  | _ -> raise (FatalException(${path.slice(0, -1)} must be an array."))
            `
                .replace(/\n {16}/gu, "\n")
                .trim();
        }
        default:
            throw new Error(`BUG: decodeType with ${type.constructor.name}`);
    }
}
exports.decodeType = decodeType;
function encodeType(type, valueVar, path, suffix = 1, isRef = true) {
    switch (type.constructor) {
        case parser_1.StringPrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar})`;
        }
        case parser_1.FloatPrimitiveType:
        case parser_1.UIntPrimitiveType:
        case parser_1.IntPrimitiveType: {
            return `resultWriter_.WriteNumberValue(${valueVar})`;
        }
        case parser_1.MoneyPrimitiveType: {
            return `resultWriter_.WriteNumberValue(int (Math.Round(${valueVar} * 100m)))`;
        }
        case parser_1.BigIntPrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar}.ToString())`;
        }
        case parser_1.BoolPrimitiveType: {
            return `resultWriter_.WriteBooleanValue(${valueVar})`;
        }
        case parser_1.BytesPrimitiveType: {
            return `resultWriter_.WriteStringValue(Convert.ToBase64String(${valueVar}))`;
        }
        case parser_1.DateTimePrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar}.ToString("yyyy-MM-ddTHH:mm:ss.FFFFFF'Z'"))`;
        }
        case parser_1.DatePrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar}.ToString("yyyy-MM-dd"))`;
        }
        // TODO: format those
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.XmlPrimitiveType: {
            return `resultWriter_.WriteStringValue(${valueVar})`;
        }
        case parser_1.OptionalType: {
            let realBaseType = type.base;
            while (realBaseType instanceof parser_1.TypeReference) {
                realBaseType = realBaseType.type;
            }
            return `
              if (${valueVar}.IsNone) then
                resultWriter_.WriteNullValue()
              else
                ${encodeType(realBaseType, `${valueVar}.Value`, path, suffix, isRef)}
              `
                .replace(/\n {14}/gu, "\n")
                .trim();
        }
        case parser_1.TypeReference:
            return encodeType(type.type, valueVar, path, suffix, isRef);
        case parser_1.EnumType:
            return `Encode${type.name} ${valueVar} resultWriter_ ${path}`;
        case parser_1.StructType:
            return `Encode${type.name} ${valueVar} resultWriter_ ${path}`;
        case parser_1.JsonPrimitiveType:
            return `${valueVar}.WriteTo(resultWriter_)`;
        case parser_1.ArrayType: {
            return `
              resultWriter_.WriteStartArray()
              for i${suffix} in 0..${valueVar}.Length - 1 do
                ${encodeType(type.base, `${valueVar}.[i${suffix}]`, `${path}`, suffix + 1).replace(/\n/gu, "\n                ")}
              resultWriter_.WriteEndArray()
              `
                .replace(/\n {14}/gu, "\n")
                .trim();
        }
        default:
            throw new Error(`BUG: encodeType with ${type.constructor.name}`);
    }
}
exports.encodeType = encodeType;
function generateStruct(struct) {
    return `
type ${struct.name} = {
  ${struct.fields.map(field => `${capitalize(field.name)}: ${generateTypeName(field.type)}`).join(";\n  ")}
} with
  static member Create (${struct.fields.map(field => `${ident(field.name)}: ${generateTypeName(field.type)}`).join(", ")}): ${struct.name} =
    { ${struct.fields.map(field => `${capitalize(field.name)} = ${ident(field.name)}`).join("; ")} }

let Decode${struct.name} (json_: JsonElement) (path_: string): ${struct.name} =
  if (json_.ValueKind <> JsonValueKind.Object) then raise (FatalException($"'{path_}' must be an object."))
  ${struct.fields
        .map(field => `
  let ${field.name}Json_ = decodeJsonElementStrict ${JSON.stringify(field.name)} json_ $"{path_}.${field.name}"
  let ${ident(field.name)} =
    ${decodeType(field.type, `${field.name}Json_`, `$"{path_}.${field.name}"`, ident(field.name)).replace(/\n/gu, "\n  ")}
  `)
        .join("")}
  { ${struct.fields.map(field => `${capitalize(field.name)} = ${ident(field.name)}`).join("; ")} }

let Encode${struct.name} (obj_: ${struct.name}) (resultWriter_: Utf8JsonWriter) (path_: string) =
  resultWriter_.WriteStartObject()
  ${struct.fields
        .map(field => `
  resultWriter_.WritePropertyName(${JSON.stringify(field.name)})
  ${encodeType(field.type, `obj_.${capitalize(field.name)}`, `$"{path_}.${field.name}"`).replace(/\n/gu, "\n  ")}`)
        .join("\n")}
  resultWriter_.WriteEndObject()`;
}
exports.generateStruct = generateStruct;
function generateEnum(type) {
    return `
type ${type.name} =
  ${type.values.map(({ value }) => `| ${capitalize(value)}`).join("\n  ")}

let Decode${type.name} (json_: JsonElement) (path_: string): ${type.name} =
  if (json_.ValueKind <> JsonValueKind.String) then raise (FatalException($"'{path_}' must be a string."))
  match json_.GetString() with
  ${type.values.map(({ value }) => `| "${value}" -> ${type.name}.${capitalize(value)}`).join("\n  ")}
  | _ -> raise (FatalException($"'{path_}' must be one of: (${type.values.map(({ value }) => `'${value}'`).join(", ")})."))

let Encode${type.name} (obj_: ${type.name}) (resultWriter_: Utf8JsonWriter) (path_: string) =
  match obj_ with
  ${type.values.map(({ value }) => `| ${type.name}.${capitalize(value)} -> resultWriter_.WriteStringValue("${value}")`).join("\n  ")}

`;
}
exports.generateEnum = generateEnum;
