"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compatibilityIssues = void 0;
const ast_1 = require("../ast");
/*
 * 1 -> Old version
 * 2 -> New version
 */
function checkClientToServer(path, issues, t1, t2) {
    var _a, _b;
    if (t1 instanceof ast_1.TypeReference) {
        checkClientToServer(path, issues, t1.type, t2);
        return;
    }
    if (t2 instanceof ast_1.TypeReference) {
        checkClientToServer(path, issues, t1, t2.type);
        return;
    }
    if (!(t1 instanceof ast_1.OptionalType) && t2 instanceof ast_1.OptionalType) {
        checkClientToServer(path, issues, t1, t2.base);
        return;
    }
    if (t1 instanceof ast_1.OptionalType && t2 instanceof ast_1.OptionalType) {
        checkClientToServer(path, issues, t1.base, t2.base);
        return;
    }
    if (t1 instanceof ast_1.OptionalType && !(t2 instanceof ast_1.OptionalType)) {
        issues.push(`${path} was optional, but now it isn't. If the client sends a null, it will be invalid. Add the optional annotation back.`);
        checkClientToServer(path, issues, t1.base, t2);
        return;
    }
    if (t1 instanceof ast_1.ArrayType && t2 instanceof ast_1.ArrayType) {
        checkClientToServer(path, issues, t1.base, t2.base);
        return;
    }
    if (t1 instanceof ast_1.StructType && t2 instanceof ast_1.StructType) {
        for (const field2 of t2.fields) {
            const field1 = t1.fields.find(x => x.name === field2.name);
            if (!field1) {
                if (field2.type instanceof ast_1.OptionalType) {
                    continue;
                }
                else {
                    issues.push(`${path}.${field2.name} didn't exist before and isn't optional. Make it optional.`);
                    continue;
                }
            }
            checkClientToServer(`${path}.${field1.name}`, issues, field1.type, field2.type);
        }
        return;
    }
    if ((t1 instanceof ast_1.UIntPrimitiveType && t2 instanceof ast_1.IntPrimitiveType) ||
        (t1 instanceof ast_1.IntPrimitiveType && t2 instanceof ast_1.FloatPrimitiveType) ||
        (t1 instanceof ast_1.MoneyPrimitiveType && t2 instanceof ast_1.IntPrimitiveType) ||
        (t1 instanceof ast_1.MoneyPrimitiveType && t2 instanceof ast_1.UIntPrimitiveType) ||
        (t1 instanceof ast_1.UIntPrimitiveType && t2 instanceof ast_1.BigIntPrimitiveType) ||
        (t1 instanceof ast_1.IntPrimitiveType && t2 instanceof ast_1.BigIntPrimitiveType) ||
        (t1 instanceof ast_1.MoneyPrimitiveType && t2 instanceof ast_1.BigIntPrimitiveType) ||
        (t1 instanceof ast_1.BigIntPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.UuidPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.XmlPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.DatePrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.DateTimePrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.CpfPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.CnpjPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.HexPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.HtmlPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.Base64PrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.BytesPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.BytesPrimitiveType && t2 instanceof ast_1.Base64PrimitiveType) ||
        (t1 instanceof ast_1.UrlPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.EmailPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.DecimalPrimitiveType && t2 instanceof ast_1.StringPrimitiveType) ||
        (t1 instanceof ast_1.EnumType && t2 instanceof ast_1.StringPrimitiveType)) {
        return;
    }
    if (t1 instanceof ast_1.EnumType && t2 instanceof ast_1.EnumType) {
        for (const value of t1.values) {
            const other = t2.values.find(v => v.value === value.value);
            if (other) {
                checkClientToServer(`${path}.${value.value}`, issues, (_a = value.struct) !== null && _a !== void 0 ? _a : new ast_1.StructType([]), (_b = other.struct) !== null && _b !== void 0 ? _b : new ast_1.StructType([]));
            }
            else {
                issues.push(`The enum at ${path} used to accept the value "${value.value}" that doesn't exist now. Clients that send it will fail.`);
            }
        }
        return;
    }
    if (t1.constructor.name === t2.constructor.name) {
        return;
    }
    issues.push(`${path} was ${t1.name} and now it is ${t2.name}. They are not compatible.`);
}
function checkServerToClient(path, issues, t1, t2) {
    var _a, _b;
    if (t1 instanceof ast_1.TypeReference) {
        checkServerToClient(path, issues, t1.type, t2);
        return;
    }
    if (t2 instanceof ast_1.TypeReference) {
        checkServerToClient(path, issues, t1, t2.type);
        return;
    }
    if (t1 instanceof ast_1.OptionalType && !(t2 instanceof ast_1.OptionalType)) {
        checkServerToClient(path, issues, t1.base, t2);
        return;
    }
    if (t1 instanceof ast_1.OptionalType && t2 instanceof ast_1.OptionalType) {
        checkServerToClient(path, issues, t1.base, t2.base);
        return;
    }
    if (!(t1 instanceof ast_1.OptionalType) && t2 instanceof ast_1.OptionalType) {
        issues.push(`${path} wasn't optional, but now it is. If the client receives a null, it will crash. Remove the optional annotation.`);
        checkServerToClient(path, issues, t1, t2.base);
        return;
    }
    if (t1 instanceof ast_1.ArrayType && t2 instanceof ast_1.ArrayType) {
        checkServerToClient(path, issues, t1.base, t2.base);
        return;
    }
    if (t1 instanceof ast_1.StructType && t2 instanceof ast_1.StructType) {
        for (const field1 of t1.fields) {
            const field2 = t2.fields.find(x => x.name === field1.name);
            if (!field2) {
                if (field1.type instanceof ast_1.OptionalType) {
                    continue;
                }
                else {
                    issues.push(`${path}.${field1.name} used to exist with type ${field1.type.name}, but it's now missing. Add it back.`);
                    continue;
                }
            }
            checkServerToClient(`${path}.${field1.name}`, issues, field1.type, field2.type);
        }
        return;
    }
    if ((t1 instanceof ast_1.IntPrimitiveType && t2 instanceof ast_1.UIntPrimitiveType) ||
        (t1 instanceof ast_1.FloatPrimitiveType && t2 instanceof ast_1.IntPrimitiveType) ||
        (t1 instanceof ast_1.IntPrimitiveType && t2 instanceof ast_1.MoneyPrimitiveType) ||
        (t1 instanceof ast_1.UIntPrimitiveType && t2 instanceof ast_1.MoneyPrimitiveType) ||
        (t1 instanceof ast_1.BigIntPrimitiveType && t2 instanceof ast_1.UIntPrimitiveType) ||
        (t1 instanceof ast_1.BigIntPrimitiveType && t2 instanceof ast_1.IntPrimitiveType) ||
        (t1 instanceof ast_1.BigIntPrimitiveType && t2 instanceof ast_1.MoneyPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.BigIntPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.UuidPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.XmlPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.DatePrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.DateTimePrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.CpfPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.CnpjPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.HexPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.HtmlPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.Base64PrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.BytesPrimitiveType) ||
        (t1 instanceof ast_1.Base64PrimitiveType && t2 instanceof ast_1.BytesPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.UrlPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.EmailPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.DecimalPrimitiveType) ||
        (t1 instanceof ast_1.StringPrimitiveType && t2 instanceof ast_1.EnumType)) {
        return;
    }
    if (t1 instanceof ast_1.EnumType && t2 instanceof ast_1.EnumType) {
        for (const value of t2.values) {
            const other = t1.values.find(v => v.value === value.value);
            if (other) {
                checkServerToClient(`${path}.${value.value}`, issues, (_a = other.struct) !== null && _a !== void 0 ? _a : new ast_1.StructType([]), (_b = value.struct) !== null && _b !== void 0 ? _b : new ast_1.StructType([]));
            }
            else {
                issues.push(`The enum at ${path} now has the value "${value.value}" that didn't exist before. Client will crash if it receives it`);
            }
        }
        return;
    }
    if (t1.constructor.name === t2.constructor.name) {
        return;
    }
    issues.push(`${path} was ${t1.name} and now it is ${t2.name}. They are not compatible.`);
}
function compatibilityIssues(ast1, ast2) {
    const issues = [];
    for (const op1 of ast1.operations) {
        const op2 = ast2.operations.find(x => x.name === op1.name);
        if (!op2) {
            issues.push(`function ${op1.name} used to exist, but it's now missing. Add it back.`);
            continue;
        }
        checkServerToClient(`${op1.name}.ret`, issues, op1.returnType, op2.returnType);
        for (const arg2 of op2.args) {
            const arg1 = op1.args.find(x => x.name === arg2.name);
            if (!arg1) {
                if (arg2.type instanceof ast_1.OptionalType) {
                    continue;
                }
                else {
                    issues.push(`${op1.name}.args.${arg2.name} didn't exist before and isn't optional. Make it optional.`);
                    continue;
                }
            }
            checkClientToServer(`${op1.name}.args.${arg1.name}`, issues, arg1.type, arg2.type);
        }
    }
    for (const err1 of ast1.errors) {
        const err2 = ast2.errors.find(x => x.name === err1.name);
        if (!err2) {
            continue;
        }
        checkServerToClient(`${err1.name}.data`, issues, err1.dataType, err2.dataType);
    }
    return issues;
}
exports.compatibilityIssues = compatibilityIssues;
