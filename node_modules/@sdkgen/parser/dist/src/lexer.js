"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lexer = exports.LexerError = void 0;
const token_1 = require("./token");
class LexerError extends Error {
}
exports.LexerError = LexerError;
class Lexer {
    constructor(source, filename = "-") {
        this.source = source;
        this.filename = filename;
        this.startPos = 0;
        this.startLine = 1;
        this.startColumn = 1;
        this.pos = 0;
        this.line = 1;
        this.column = 1;
    }
    currentChar() {
        return this.source[this.pos] || "\0";
    }
    nextChar() {
        this.column++;
        return this.source[++this.pos] || "\0";
    }
    nextToken() {
        this.startPos = this.pos;
        this.startLine = this.line;
        this.startColumn = this.column;
        let token = null;
        switch (this.currentChar()) {
            case "\0":
                return null;
            case " ":
            case "\r":
            case "\t":
                this.nextChar();
                return this.nextToken();
            case "\n":
                this.nextChar();
                this.column = 1;
                this.line++;
                return this.nextToken();
            case "/":
                switch (this.nextChar()) {
                    case "/":
                        for (;;) {
                            switch (this.nextChar()) {
                                case "\0":
                                    return null;
                                case "\n":
                                    this.nextChar();
                                    this.column = 1;
                                    this.line++;
                                    return this.nextToken();
                                default:
                                    break;
                            }
                        }
                    case "*":
                        // eslint-disable-next-line no-labels
                        outerWhile: for (;;) {
                            switch (this.nextChar()) {
                                case "\0":
                                    // eslint-disable-next-line no-labels
                                    break outerWhile;
                                case "\n":
                                    this.column = 0;
                                    this.line++;
                                    break;
                                case "*":
                                    while (this.nextChar() === "*") {
                                        //
                                    }
                                    switch (this.currentChar()) {
                                        case "\0":
                                            // eslint-disable-next-line no-labels
                                            break outerWhile;
                                        case "\n":
                                            this.column = 0;
                                            this.line++;
                                            break;
                                        case "/":
                                            this.nextChar();
                                            return this.nextToken();
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }
                        break;
                    default:
                        break;
                }
                break;
            case "{":
                this.nextChar();
                token = new token_1.CurlyOpenSymbolToken();
                break;
            case "}":
                this.nextChar();
                token = new token_1.CurlyCloseSymbolToken();
                break;
            case "(":
                this.nextChar();
                token = new token_1.ParensOpenSymbolToken();
                break;
            case ")":
                this.nextChar();
                token = new token_1.ParensCloseSymbolToken();
                break;
            case "?":
                this.nextChar();
                token = new token_1.OptionalSymbolToken();
                break;
            case ":":
                this.nextChar();
                token = new token_1.ColonSymbolToken();
                break;
            case "=":
                this.nextChar();
                token = new token_1.EqualSymbolToken();
                break;
            case "!":
                this.nextChar();
                token = new token_1.ExclamationMarkSymbolToken();
                break;
            case ",":
                this.nextChar();
                token = new token_1.CommaSymbolToken();
                break;
            case "[":
                switch (this.nextChar()) {
                    case "]": {
                        this.nextChar();
                        token = new token_1.ArraySymbolToken();
                        break;
                    }
                    default:
                        break;
                }
                break;
            case ".":
                switch (this.nextChar()) {
                    case ".": {
                        switch (this.nextChar()) {
                            case ".": {
                                this.nextChar();
                                token = new token_1.SpreadSymbolToken();
                                break;
                            }
                            default:
                                break;
                        }
                        break;
                    }
                    default:
                        break;
                }
                break;
            case "@": {
                let body = "\\";
                let pos = this.startPos + 1;
                while (body.endsWith("\\")) {
                    body = body.slice(0, body.length - 1).trim();
                    while (!["\0", "\n"].includes(this.nextChar())) {
                        //
                    }
                    body = `${body} ${this.source.substring(pos, this.pos).trim()}`.trim();
                    pos = this.pos + 1;
                }
                token = new token_1.AnnotationToken(body.trim());
                break;
            }
            case '"': {
                const chars = [];
                // eslint-disable-next-line no-labels
                outerLoop: for (;;) {
                    switch (this.nextChar()) {
                        case "\0":
                            // eslint-disable-next-line no-labels
                            break outerLoop;
                        case "\\":
                            switch (this.nextChar()) {
                                case "\0":
                                    // eslint-disable-next-line no-labels
                                    break outerLoop;
                                case "n":
                                    chars.push("\n");
                                    break;
                                case "t":
                                    chars.push("\t");
                                    break;
                                default:
                                    chars.push(this.currentChar());
                                    break;
                            }
                            break;
                        case '"':
                            this.nextChar();
                            token = new token_1.StringLiteralToken(chars.join(""));
                            // eslint-disable-next-line no-labels
                            break outerLoop;
                        default:
                            chars.push(this.currentChar());
                            break;
                    }
                }
                break;
            }
            default: {
                if (/[a-zA-Z_]/u.test(this.currentChar())) {
                    while (/[a-zA-Z0-9_]/u.test(this.nextChar())) {
                        //
                    }
                    const ident = this.source.substring(this.startPos, this.pos);
                    switch (ident) {
                        case "error":
                            token = new token_1.ErrorKeywordToken();
                            break;
                        case "enum":
                            token = new token_1.EnumKeywordToken();
                            break;
                        case "type":
                            token = new token_1.TypeKeywordToken();
                            break;
                        case "import":
                            token = new token_1.ImportKeywordToken();
                            break;
                        case "fn":
                            token = new token_1.FnKeywordToken();
                            break;
                        case "true":
                            token = new token_1.TrueKeywordToken();
                            break;
                        case "false":
                            token = new token_1.FalseKeywordToken();
                            break;
                        default:
                            token = Lexer.PRIMITIVES.has(ident) ? new token_1.PrimitiveTypeToken(ident) : new token_1.IdentifierToken(ident);
                    }
                }
            }
        }
        if (token !== null) {
            token.location.filename = this.filename;
            token.location.line = this.startLine;
            token.location.column = this.startColumn;
            return token;
        }
        if (this.currentChar() === "\0") {
            throw new LexerError(`Unexpected end of file at ${this.filename}`);
        }
        else {
            throw new LexerError(`Unexpected character ${JSON.stringify(this.currentChar())} at ${this.filename}:${this.line}:${this.column}`);
        }
    }
}
exports.Lexer = Lexer;
Lexer.PRIMITIVES = new Set([
    "bool",
    "int",
    "uint",
    "float",
    "bigint",
    "string",
    "date",
    "datetime",
    "bytes",
    "money",
    "decimal",
    "cpf",
    "cnpj",
    "email",
    "html",
    "url",
    "uuid",
    "hex",
    "base64",
    "xml",
    "void",
    "json",
]);
Lexer.KEYWORDS = new Set([...Lexer.PRIMITIVES, "error", "enum", "type", "import", "get", "function", "fn", "true", "false"]);
