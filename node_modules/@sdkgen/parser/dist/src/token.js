"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrimitiveTypeToken = exports.FalseKeywordToken = exports.TrueKeywordToken = exports.ErrorKeywordToken = exports.FnKeywordToken = exports.EnumKeywordToken = exports.TypeKeywordToken = exports.ImportKeywordToken = exports.AnnotationToken = exports.SpreadSymbolToken = exports.CommaSymbolToken = exports.ArraySymbolToken = exports.OptionalSymbolToken = exports.ColonSymbolToken = exports.ParensCloseSymbolToken = exports.ParensOpenSymbolToken = exports.CurlyCloseSymbolToken = exports.CurlyOpenSymbolToken = exports.ExclamationMarkSymbolToken = exports.EqualSymbolToken = exports.StringLiteralToken = exports.IdentifierToken = exports.Token = exports.TokenLocation = void 0;
class TokenLocation {
    constructor() {
        this.filename = "?";
        this.line = 0;
        this.column = 0;
    }
    toString() {
        return `${this.filename}:${this.line}:${this.column}`;
    }
}
exports.TokenLocation = TokenLocation;
class Token {
    constructor(value = "") {
        this.value = value;
        this.location = new TokenLocation();
        Object.defineProperty(this, "location", { enumerable: false });
    }
    maybeAsIdentifier() {
        return this;
    }
    toString() {
        const name = this.constructor.name.replace("Token", "");
        return this.value === "" ? name : `${name}(${JSON.stringify(this.value)})`;
    }
}
exports.Token = Token;
class IdentifierToken extends Token {
}
exports.IdentifierToken = IdentifierToken;
class StringLiteralToken extends Token {
}
exports.StringLiteralToken = StringLiteralToken;
class EqualSymbolToken extends Token {
}
exports.EqualSymbolToken = EqualSymbolToken;
class ExclamationMarkSymbolToken extends Token {
}
exports.ExclamationMarkSymbolToken = ExclamationMarkSymbolToken;
class CurlyOpenSymbolToken extends Token {
}
exports.CurlyOpenSymbolToken = CurlyOpenSymbolToken;
class CurlyCloseSymbolToken extends Token {
}
exports.CurlyCloseSymbolToken = CurlyCloseSymbolToken;
class ParensOpenSymbolToken extends Token {
}
exports.ParensOpenSymbolToken = ParensOpenSymbolToken;
class ParensCloseSymbolToken extends Token {
}
exports.ParensCloseSymbolToken = ParensCloseSymbolToken;
class ColonSymbolToken extends Token {
}
exports.ColonSymbolToken = ColonSymbolToken;
class OptionalSymbolToken extends Token {
}
exports.OptionalSymbolToken = OptionalSymbolToken;
class ArraySymbolToken extends Token {
}
exports.ArraySymbolToken = ArraySymbolToken;
class CommaSymbolToken extends Token {
}
exports.CommaSymbolToken = CommaSymbolToken;
class SpreadSymbolToken extends Token {
}
exports.SpreadSymbolToken = SpreadSymbolToken;
class AnnotationToken extends Token {
}
exports.AnnotationToken = AnnotationToken;
class ImportKeywordToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken("import");
    }
}
exports.ImportKeywordToken = ImportKeywordToken;
class TypeKeywordToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken("type");
    }
}
exports.TypeKeywordToken = TypeKeywordToken;
class EnumKeywordToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken("enum");
    }
}
exports.EnumKeywordToken = EnumKeywordToken;
class FnKeywordToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken("fn");
    }
}
exports.FnKeywordToken = FnKeywordToken;
class ErrorKeywordToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken("error");
    }
}
exports.ErrorKeywordToken = ErrorKeywordToken;
class TrueKeywordToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken("true");
    }
}
exports.TrueKeywordToken = TrueKeywordToken;
class FalseKeywordToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken("false");
    }
}
exports.FalseKeywordToken = FalseKeywordToken;
class PrimitiveTypeToken extends Token {
    maybeAsIdentifier() {
        return new IdentifierToken(this.value);
    }
}
exports.PrimitiveTypeToken = PrimitiveTypeToken;
