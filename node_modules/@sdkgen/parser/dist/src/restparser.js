"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRestAnnotation = void 0;
const ast_1 = require("./ast");
function scanHeaders(text) {
    var _a;
    // Header name: https://tools.ietf.org/html/rfc2616#section-4.2
    const headerRegex = /\[header (?<header>[^()<>@,;:\\"/[\]?={}\s\t]+): \{(?<name>\w+)\}\]/gu;
    const headers = new Map();
    let match;
    while ((match = headerRegex.exec(text)) !== null) {
        if (((_a = match.groups) === null || _a === void 0 ? void 0 : _a.header) && match.groups.name) {
            headers.set(match.groups.header.toLowerCase(), match.groups.name);
        }
    }
    return headers;
}
function scanBody(text) {
    var _a;
    const match = /\[body \{(?<name>\w+)\}\]/u.exec(text);
    if ((_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.name) {
        return match.groups.name;
    }
    return null;
}
function scanVariables(text) {
    var _a;
    const variableRegex = /\{(?<name>\w+)\}/gu;
    const variables = [];
    let match;
    while ((match = variableRegex.exec(text)) !== null) {
        if ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.name) {
            variables.push(match.groups.name);
        }
    }
    return variables;
}
function parseRestAnnotation(text) {
    const fragments = text.split(" ");
    const method = fragments[0].toUpperCase();
    if (!["GET", "POST", "PUT", "DELETE", "PATCH"].includes(method)) {
        throw new Error(`Unsupported method '${method}'`);
    }
    // eslint-disable-next-line prefer-destructuring
    let path = fragments[1];
    if (!path.startsWith("/")) {
        throw new Error(`Invalid path`);
    }
    let queryVariables = [];
    if (path.includes("?")) {
        const [base, ...queryArray] = path.split("?");
        path = base;
        const query = queryArray.join("?");
        if (!/^\{\w+\}(?:&\{\w+\})*$/u.test(query)) {
            throw new Error(`Invalid querystring on path`);
        }
        queryVariables = scanVariables(query);
    }
    const pathVariables = scanVariables(path);
    const remaining = fragments.slice(2).join(" ");
    const headers = scanHeaders(remaining);
    const bodyVariable = scanBody(remaining);
    return new ast_1.RestAnnotation(method, path, pathVariables, queryVariables, headers, bodyVariable);
}
exports.parseRestAnnotation = parseRestAnnotation;
