"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Visitor = exports.SemanticError = void 0;
const ast_1 = require("../ast");
class SemanticError extends Error {
}
exports.SemanticError = SemanticError;
class Visitor {
    constructor(root) {
        this.root = root;
    }
    process() {
        for (const error of this.root.errors) {
            this.visit(error);
        }
        for (const typeDefinition of this.root.typeDefinitions) {
            this.visit(typeDefinition);
        }
        for (const operation of this.root.operations) {
            this.visit(operation);
        }
    }
    visit(node) {
        if (node instanceof ast_1.FunctionOperation) {
            for (const arg of node.args) {
                this.visit(arg);
            }
            for (const arg of node.fieldsAndSpreads) {
                this.visit(arg);
            }
            this.visit(node.returnType);
        }
        else if (node instanceof ast_1.Field || node instanceof ast_1.TypeDefinition) {
            this.visit(node.type);
        }
        else if (node instanceof ast_1.StructType) {
            for (const field of node.fields) {
                this.visit(field);
            }
            for (const field of node.fieldsAndSpreads) {
                this.visit(field);
            }
        }
        else if (node instanceof ast_1.EnumType) {
            for (const enumValue of node.values) {
                this.visit(enumValue);
            }
        }
        else if (node instanceof ast_1.EnumValue) {
            if (node.struct) {
                this.visit(node.struct);
            }
        }
        else if (node instanceof ast_1.ArrayType || node instanceof ast_1.OptionalType) {
            this.visit(node.base);
        }
        else if (node instanceof ast_1.ErrorNode) {
            this.visit(node.dataType);
        }
        else if (node instanceof ast_1.Spread) {
            this.visit(node.typeReference);
        }
    }
}
exports.Visitor = Visitor;
