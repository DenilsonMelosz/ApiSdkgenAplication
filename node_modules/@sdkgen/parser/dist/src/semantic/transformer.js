"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transformer = exports.SemanticError = void 0;
const ast_1 = require("../ast");
class SemanticError extends Error {
}
exports.SemanticError = SemanticError;
class Transformer {
    constructor(root) {
        this.root = root;
    }
    process() {
        this.root.errors = this.root.errors.map(x => this.transform(x));
        this.root.typeDefinitions = this.root.typeDefinitions.map(x => this.transform(x));
        this.root.operations = this.root.operations.map(x => this.transform(x));
    }
    transform(node) {
        if (node instanceof ast_1.FunctionOperation) {
            node.args = node.args.map(x => this.transform(x));
            node.fieldsAndSpreads = node.fieldsAndSpreads.map(x => this.transform(x));
            node.returnType = this.transform(node.returnType);
        }
        else if (node instanceof ast_1.Field || node instanceof ast_1.TypeDefinition) {
            node.type = this.transform(node.type);
        }
        else if (node instanceof ast_1.StructType) {
            node.fields = node.fields.map(x => this.transform(x));
            node.fieldsAndSpreads = node.fieldsAndSpreads.map(x => this.transform(x));
        }
        else if (node instanceof ast_1.EnumType) {
            node.values = node.values.map(x => this.transform(x));
        }
        else if (node instanceof ast_1.EnumValue) {
            if (node.struct) {
                node.struct = this.transform(node.struct);
            }
        }
        else if (node instanceof ast_1.ArrayType || node instanceof ast_1.OptionalType) {
            node.base = this.transform(node.base);
        }
        else if (node instanceof ast_1.ErrorNode) {
            node.dataType = this.transform(node.dataType);
        }
        else if (node instanceof ast_1.Spread) {
            node.typeReference = this.transform(node.typeReference);
        }
        return node;
    }
}
exports.Transformer = Transformer;
