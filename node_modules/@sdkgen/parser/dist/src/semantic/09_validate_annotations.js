"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateAnnotationsVisitor = void 0;
const visitor_1 = require("./visitor");
const ast_1 = require("../ast");
function isRestEncodable(type) {
    return (type instanceof ast_1.BoolPrimitiveType ||
        type instanceof ast_1.IntPrimitiveType ||
        type instanceof ast_1.UIntPrimitiveType ||
        type instanceof ast_1.BigIntPrimitiveType ||
        type instanceof ast_1.FloatPrimitiveType ||
        type instanceof ast_1.StringPrimitiveType ||
        type instanceof ast_1.DatePrimitiveType ||
        type instanceof ast_1.DateTimePrimitiveType ||
        type instanceof ast_1.MoneyPrimitiveType ||
        type instanceof ast_1.DecimalPrimitiveType ||
        type instanceof ast_1.CpfPrimitiveType ||
        type instanceof ast_1.CnpjPrimitiveType ||
        type instanceof ast_1.UuidPrimitiveType ||
        type instanceof ast_1.HexPrimitiveType ||
        type instanceof ast_1.Base64PrimitiveType ||
        type instanceof ast_1.EnumType);
}
function extractRealType(type) {
    return type instanceof ast_1.TypeReference ? extractRealType(type.type) : type;
}
class ValidateAnnotationsVisitor extends visitor_1.Visitor {
    visit(node) {
        if (node instanceof ast_1.EnumValue) {
            for (const annotation of node.annotations) {
                if (annotation instanceof ast_1.DescriptionAnnotation) {
                    // Ok
                }
                else {
                    throw new visitor_1.SemanticError(`Cannot have @${annotation.constructor.name.replace("Annotation", "").toLowerCase()} at ${annotation.location}`);
                }
            }
        }
        else if (node instanceof ast_1.TypeDefinition) {
            for (const annotation of node.annotations) {
                if (annotation instanceof ast_1.DescriptionAnnotation) {
                    // Ok
                }
                else {
                    throw new visitor_1.SemanticError(`Cannot have @${annotation.constructor.name.replace("Annotation", "").toLowerCase()} at ${annotation.location}`);
                }
            }
        }
        else if (node instanceof ast_1.Field) {
            for (const annotation of node.annotations) {
                if (annotation instanceof ast_1.DescriptionAnnotation) {
                    // Ok
                }
                else {
                    throw new visitor_1.SemanticError(`Cannot have @${annotation.constructor.name.replace("Annotation", "").toLowerCase()} at ${annotation.location}`);
                }
            }
        }
        else if (node instanceof ast_1.FunctionOperation) {
            for (const annotation of node.annotations) {
                if (annotation instanceof ast_1.DescriptionAnnotation) {
                    // Ok
                }
                else if (annotation instanceof ast_1.ThrowsAnnotation) {
                    if (!this.root.errors.some(error => error.name === annotation.error)) {
                        throw new visitor_1.SemanticError(`Unknown error type '${annotation.error}' at ${annotation.location}`);
                    }
                }
                else if (annotation instanceof ast_1.RestAnnotation) {
                    const allVariables = [...annotation.pathVariables, ...annotation.queryVariables, ...annotation.headers.values()];
                    if (allVariables.length !== new Set(allVariables).size) {
                        throw new visitor_1.SemanticError(`Arguments must appear only once for rest annotation at ${annotation.location}`);
                    }
                    for (const name of allVariables) {
                        const arg = node.args.find(x => x.name === name);
                        if (!arg) {
                            throw new visitor_1.SemanticError(`Argument '${name}' not found at ${annotation.location}`);
                        }
                        if (annotation.pathVariables.includes(name) && arg.type instanceof ast_1.OptionalType) {
                            throw new visitor_1.SemanticError(`The path argument '${name}' can't be nullable at ${annotation.location}`);
                        }
                        const baseType = arg.type instanceof ast_1.OptionalType ? arg.type.base : arg.type;
                        if (!isRestEncodable(extractRealType(baseType))) {
                            throw new visitor_1.SemanticError(`Argument '${name}' can't have type '${arg.type.name}' for rest annotation at ${annotation.location}`);
                        }
                    }
                    for (const arg of node.args) {
                        if (!allVariables.includes(arg.name) && annotation.bodyVariable !== arg.name) {
                            throw new visitor_1.SemanticError(`Argument '${arg.name}' is missing from the rest annotation at ${annotation.location}`);
                        }
                        const queryAndPathVariables = [...annotation.pathVariables, ...annotation.queryVariables];
                        if (annotation.method === "GET" && queryAndPathVariables.includes(arg.name) && arg.secret) {
                            throw new visitor_1.SemanticError(`Argument marked as secret cannot be used in the path or query parts of a GET endpoint at ${annotation.location}`);
                        }
                    }
                    if (annotation.method === "GET" && node.returnType instanceof ast_1.VoidPrimitiveType) {
                        throw new visitor_1.SemanticError(`A GET rest endpoint must return something at ${annotation.location}`);
                    }
                }
                else if (annotation instanceof ast_1.HiddenAnnotation) {
                    // Ok
                }
                else {
                    throw new visitor_1.SemanticError(`Cannot have @${annotation.constructor.name.replace("Annotation", "").toLowerCase()} at ${annotation.location}`);
                }
            }
        }
        else if (node instanceof ast_1.ErrorNode) {
            for (const annotation of node.annotations) {
                if (annotation instanceof ast_1.StatusCodeAnnotation) {
                    if (annotation.statusCode < 400 || annotation.statusCode > 599) {
                        throw new visitor_1.SemanticError(`Error status code can only be 4xx or 5xx at ${annotation.location}`);
                    }
                }
                else {
                    throw new visitor_1.SemanticError(`Cannot have @${annotation.constructor.name.replace("Annotation", "").toLowerCase()} at ${annotation.location}`);
                }
            }
            if (node.annotations.filter(ann => ann instanceof ast_1.StatusCodeAnnotation).length > 1) {
                throw new visitor_1.SemanticError(`Can't provide more than one status code at ${node.location}`);
            }
        }
    }
}
exports.ValidateAnnotationsVisitor = ValidateAnnotationsVisitor;
