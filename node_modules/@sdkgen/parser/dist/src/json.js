"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonToAst = exports.astToJson = void 0;
const ast_1 = require("./ast");
const analyser_1 = require("./semantic/analyser");
const utils_1 = require("./utils");
function annotationToJson(ann) {
    if (ann instanceof ast_1.DescriptionAnnotation) {
        return { type: "description", value: ann.text };
    }
    else if (ann instanceof ast_1.ThrowsAnnotation) {
        return { type: "throws", value: ann.error };
    }
    else if (ann instanceof ast_1.RestAnnotation) {
        return {
            type: "rest",
            value: {
                bodyVariable: ann.bodyVariable,
                headers: [...ann.headers.entries()].sort(([a], [b]) => a.localeCompare(b)),
                method: ann.method,
                path: ann.path,
                pathVariables: ann.pathVariables,
                queryVariables: [...ann.queryVariables].sort((a, b) => a.localeCompare(b)),
            },
        };
    }
    else if (ann instanceof ast_1.HiddenAnnotation) {
        return { type: "hidden", value: null };
    }
    else if (ann instanceof ast_1.StatusCodeAnnotation) {
        return { type: "statusCode", value: ann.statusCode };
    }
    throw new Error(`BUG: annotationToJson with ${ann.constructor.name}`);
}
function annotationFromJson(json) {
    switch (json.type) {
        case "description":
            return new ast_1.DescriptionAnnotation(json.value);
        case "throws":
            return new ast_1.ThrowsAnnotation(json.value);
        case "rest": {
            const { method, path, pathVariables, queryVariables, headers, bodyVariable } = json.value;
            return new ast_1.RestAnnotation(method, path, pathVariables, queryVariables, new Map(headers), bodyVariable);
        }
        case "hidden":
            return new ast_1.HiddenAnnotation();
        case "statusCode":
            return new ast_1.StatusCodeAnnotation(json.value);
        default:
            throw new Error(`BUG: annotationFromJson with ${json.type}`);
    }
}
function astToJson(ast) {
    var _a, _b, _c, _d;
    const annotations = {};
    const typeTable = {};
    function processType(type) {
        if (type instanceof ast_1.ArrayType) {
            return `${processType(type.base)}[]`;
        }
        else if (type instanceof ast_1.OptionalType) {
            return `${processType(type.base)}?`;
        }
        return type.name;
    }
    for (const { name, fields } of ast.structTypes) {
        if (name in typeTable) {
            throw new Error(`Duplicate struct type ${name}`);
        }
        typeTable[name] = {};
        const obj = typeTable[name];
        for (const field of fields) {
            obj[field.name] = processType(field.type);
            for (const ann of field.annotations) {
                if (ann instanceof ast_1.DescriptionAnnotation) {
                    const target = `type.${name}.${field.name}`;
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    (_a = annotations[target]) !== null && _a !== void 0 ? _a : (annotations[target] = []);
                    annotations[target].push(annotationToJson(ann));
                }
            }
        }
    }
    for (const { name, values } of ast.enumTypes) {
        if (name in typeTable) {
            throw new Error(`Duplicate enum type ${name}`);
        }
        typeTable[name] = values.map(v => {
            if (!v.struct) {
                return v.value;
            }
            return [v.value, v.struct.name];
        });
    }
    for (const { name, type } of ast.typeDefinitions) {
        if (type instanceof ast_1.StructType || type instanceof ast_1.EnumType) {
            continue;
        }
        typeTable[name] = processType(type);
    }
    const functionTable = {};
    for (const op of ast.operations) {
        const args = {};
        for (const arg of op.args) {
            args[arg.name] = processType(arg.type);
            for (const ann of arg.annotations) {
                if (ann instanceof ast_1.DescriptionAnnotation) {
                    const target = `fn.${op.name}.${arg.name}`;
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    (_b = annotations[target]) !== null && _b !== void 0 ? _b : (annotations[target] = []);
                    annotations[target].push(annotationToJson(ann));
                }
            }
        }
        functionTable[op.name] = {
            args,
            ret: processType(op.returnType),
        };
        for (const ann of op.annotations) {
            const target = `fn.${op.name}`;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            (_c = annotations[target]) !== null && _c !== void 0 ? _c : (annotations[target] = []);
            annotations[target].push(annotationToJson(ann));
        }
    }
    const errors = ast.errors.map(error => error.dataType instanceof ast_1.VoidPrimitiveType ? error.name : [error.name, error.dataType.name]);
    for (const error of ast.errors) {
        for (const ann of error.annotations) {
            const target = `error.${error.name}`;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            (_d = annotations[target]) !== null && _d !== void 0 ? _d : (annotations[target] = []);
            annotations[target].push(annotationToJson(ann));
        }
    }
    return {
        annotations,
        errors,
        functionTable,
        typeTable,
    };
}
exports.astToJson = astToJson;
function jsonToAst(json) {
    var _a, _b;
    const operations = [];
    const typeDefinition = [];
    const solveEnumValueStructRef = [];
    function processType(description, typeName) {
        var _a;
        if (typeof description === "string") {
            const primitiveClass = utils_1.primitiveToAstClass.get(description);
            if (primitiveClass) {
                return new primitiveClass();
            }
            else if (description.endsWith("?")) {
                return new ast_1.OptionalType(processType(description.slice(0, description.length - 1)));
            }
            else if (description.endsWith("[]")) {
                return new ast_1.ArrayType(processType(description.slice(0, description.length - 2)));
            }
            return new ast_1.TypeReference(description);
        }
        else if (Array.isArray(description)) {
            return new ast_1.EnumType(description.map(v => {
                if (Array.isArray(v)) {
                    const [value, structName] = v;
                    const enumValue = new ast_1.EnumValue(value);
                    solveEnumValueStructRef.push([enumValue, structName]);
                    return enumValue;
                }
                return new ast_1.EnumValue(v);
            }));
        }
        const fields = [];
        for (const fieldName of Object.keys(description)) {
            const field = new ast_1.Field(fieldName, processType(description[fieldName]));
            if (typeName) {
                const target = `type.${typeName}.${fieldName}`;
                for (const annotationJson of (_a = json.annotations[target]) !== null && _a !== void 0 ? _a : []) {
                    field.annotations.push(annotationFromJson(annotationJson));
                }
            }
            fields.push(field);
        }
        return new ast_1.StructType(fields);
    }
    for (const [typeName, description] of Object.entries(json.typeTable)) {
        const type = processType(description, typeName);
        typeDefinition.push(new ast_1.TypeDefinition(typeName, type));
    }
    for (const [functionName, func] of Object.entries(json.functionTable)) {
        const args = Object.keys(func.args).map(argName => {
            var _a;
            const field = new ast_1.Field(argName, processType(func.args[argName]));
            const target = `fn.${functionName}.${argName}`;
            for (const annotationJson of (_a = json.annotations[target]) !== null && _a !== void 0 ? _a : []) {
                field.annotations.push(annotationFromJson(annotationJson));
            }
            return field;
        });
        const op = new ast_1.FunctionOperation(functionName, args, processType(func.ret));
        const target = `fn.${functionName}`;
        for (const annotationJson of (_a = json.annotations[target]) !== null && _a !== void 0 ? _a : []) {
            op.annotations.push(annotationFromJson(annotationJson));
        }
        operations.push(op);
    }
    for (const [enumValue, structName] of solveEnumValueStructRef) {
        const struct = (_b = typeDefinition.find(def => def.name === structName)) === null || _b === void 0 ? void 0 : _b.type;
        if (struct instanceof ast_1.StructType) {
            enumValue.struct = struct;
        }
    }
    const errors = json.errors.map(error => {
        var _a;
        let errorNode;
        if (Array.isArray(error)) {
            const [name, type] = error;
            errorNode = new ast_1.ErrorNode(name, processType(type));
        }
        else {
            errorNode = new ast_1.ErrorNode(error, new ast_1.VoidPrimitiveType());
        }
        const target = `error.${errorNode.name}`;
        for (const annotationJson of (_a = json.annotations[target]) !== null && _a !== void 0 ? _a : []) {
            errorNode.annotations.push(annotationFromJson(annotationJson));
        }
        return errorNode;
    });
    const ast = new ast_1.AstRoot(typeDefinition, operations, errors);
    (0, analyser_1.analyse)(ast);
    return ast;
}
exports.jsonToAst = jsonToAst;
