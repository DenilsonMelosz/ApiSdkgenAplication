"use strict";
/* eslint-disable no-sync */
/* eslint-disable no-loop-func */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = exports.ParserError = void 0;
const ast_1 = require("./ast");
const lexer_1 = require("./lexer");
const restparser_1 = require("./restparser");
const analyser_1 = require("./semantic/analyser");
const token_1 = require("./token");
const utils_1 = require("./utils");
class ParserError extends Error {
}
exports.ParserError = ParserError;
class Parser {
    constructor(source) {
        this.token = null;
        this.annotations = [];
        this.warnings = [];
        this.readFileSync = () => {
            throw "Not implemented";
        };
        try {
            // eslint-disable-next-line
            this.readFileSync = require("fs").readFileSync;
        }
        catch (e) {
            // do nothing
        }
        const sources = Array.isArray(source) ? [...source].reverse() : [source];
        this.lexers = sources.map(x => (x instanceof lexer_1.Lexer ? x : new lexer_1.Lexer(this.readFileSync(x).toString(), x)));
        this.nextToken();
    }
    nextToken() {
        while (this.lexers.length > 0) {
            this.token = this.lexers[this.lexers.length - 1].nextToken();
            if (this.token) {
                return;
            }
            this.lexers.pop();
        }
    }
    multiExpect(matcher) {
        if (!this.token) {
            throw new ParserError(`Expected ${Object.keys(matcher)
                .map(x => x.replace("Token", ""))
                .join(" or ")}, but found end of file`);
        }
        const tokenName = this.token.constructor.name;
        if (tokenName in matcher) {
            return matcher[tokenName](this.token);
        }
        else if (matcher.IdentifierToken) {
            const tokenAsIdent = this.token.maybeAsIdentifier();
            if (tokenAsIdent instanceof token_1.IdentifierToken) {
                return matcher.IdentifierToken(tokenAsIdent);
            }
        }
        throw new ParserError(`Expected ${Object.keys(matcher)
            .map(x => x.replace("Token", ""))
            .join(" or ")} at ${this.token.location}, but found ${this.token}`);
    }
    expect(type) {
        if (this.token === null) {
            throw new ParserError(`Expected ${type.name.replace("Token", "")}, but found end of file`);
        }
        else if (this.token instanceof type) {
            return this.token;
        }
        else {
            if (type === token_1.IdentifierToken) {
                const tokenAsIdent = this.token.maybeAsIdentifier();
                if (tokenAsIdent instanceof token_1.IdentifierToken) {
                    return tokenAsIdent;
                }
            }
            throw new ParserError(`Expected ${type.name.replace("Token", "")} at ${this.token.location}, but found ${this.token}`);
        }
    }
    parse() {
        const operations = [];
        const typeDefinition = [];
        const errors = [];
        this.warnings = [];
        while (this.token) {
            this.acceptAnnotations();
            this.multiExpect({
                ErrorKeywordToken: () => {
                    errors.push(this.parseError());
                },
                FnKeywordToken: () => {
                    operations.push(this.parseOperation());
                },
                ImportKeywordToken: () => {
                    this.checkCannotHaveAnnotationsHere();
                    this.nextToken();
                    const pathToken = this.expect(token_1.StringLiteralToken);
                    const resolvedPath = pathToken.location.filename.replace(/[^/\\]+$/u, `${pathToken.value}.sdkgen`);
                    this.lexers.push(new lexer_1.Lexer(this.readFileSync(resolvedPath).toString(), resolvedPath));
                    this.nextToken();
                },
                TypeKeywordToken: () => {
                    typeDefinition.push(this.parseTypeDefinition());
                },
            });
        }
        const ast = new ast_1.AstRoot(typeDefinition, operations, errors);
        ast.warnings = this.warnings;
        (0, analyser_1.analyse)(ast);
        return ast;
    }
    acceptAnnotations() {
        while (this.token instanceof token_1.AnnotationToken) {
            const words = this.token.value.split(" ");
            const body = this.token.value.slice(words[0].length).trim();
            switch (words[0]) {
                case "description":
                    this.annotations.push(new ast_1.DescriptionAnnotation(body).at(this.token));
                    break;
                case "arg":
                    this.annotations.push(new ast_1.ArgDescriptionAnnotation(words[1], this.token.value.slice(words[0].length + 1 + words[1].length).trim()).at(this.token));
                    break;
                case "throws":
                    this.annotations.push(new ast_1.ThrowsAnnotation(body).at(this.token));
                    break;
                case "rest":
                    try {
                        this.annotations.push((0, restparser_1.parseRestAnnotation)(body).at(this.token));
                    }
                    catch (error) {
                        throw new ParserError(`${error instanceof Error ? error.message : error} at ${this.token.location}`);
                    }
                    break;
                case "hidden":
                    if (body !== "") {
                        throw new ParserError(`@hidden annotation doesn't take any argument`);
                    }
                    this.annotations.push(new ast_1.HiddenAnnotation().at(this.token));
                    break;
                case "statusCode": {
                    const statusCode = parseInt(body, 10);
                    if (statusCode.toString() !== body.trim()) {
                        throw new ParserError(`@statusCode annotation takes an integer as argument`);
                    }
                    this.annotations.push(new ast_1.StatusCodeAnnotation(statusCode).at(this.token));
                    break;
                }
                default:
                    throw new ParserError(`Unknown annotation '${words[0]}' at ${this.token.location}`);
            }
            this.nextToken();
        }
    }
    checkCannotHaveAnnotationsHere() {
        if (this.annotations.length > 0) {
            throw new ParserError(`Cannot have annotations at ${this.annotations[0].location}`);
        }
    }
    parseTypeDefinition() {
        const typeToken = this.expect(token_1.TypeKeywordToken);
        this.nextToken();
        const nameToken = this.expect(token_1.IdentifierToken);
        const name = nameToken.value;
        if (!/[A-Z]/u.test(name[0])) {
            throw new ParserError(`The custom type name must start with an uppercase letter, but found ${JSON.stringify(name)} at ${nameToken.location}`);
        }
        this.nextToken();
        const { annotations } = this;
        this.annotations = [];
        const type = this.parseType();
        const definitions = new ast_1.TypeDefinition(name, type).at(typeToken);
        definitions.annotations = annotations;
        return definitions;
    }
    parseError() {
        const errorToken = this.expect(token_1.ErrorKeywordToken);
        this.nextToken();
        const nameToken = this.expect(token_1.IdentifierToken);
        const name = nameToken.value;
        if (!/[A-Z]/u.test(name[0])) {
            throw new ParserError(`Error name must start with an uppercase letter, but found ${JSON.stringify(name)} at ${nameToken.location}`);
        }
        this.nextToken();
        let type = new ast_1.VoidPrimitiveType();
        if (this.token instanceof token_1.CurlyOpenSymbolToken ||
            this.token instanceof token_1.EnumKeywordToken ||
            this.token instanceof token_1.IdentifierToken ||
            this.token instanceof token_1.PrimitiveTypeToken) {
            type = this.parseType();
        }
        const node = new ast_1.ErrorNode(name, type).at(errorToken);
        node.annotations = this.annotations;
        this.annotations = [];
        return node;
    }
    parseOperation() {
        let { annotations } = this;
        this.annotations = [];
        this.expect(token_1.FnKeywordToken);
        this.nextToken();
        const name = this.expect(token_1.IdentifierToken).value;
        this.nextToken();
        this.expect(token_1.ParensOpenSymbolToken);
        this.nextToken();
        const argNames = new Set();
        const fieldsAndSpreads = [];
        let finished = false;
        let parensCloseToken;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        while (!finished) {
            this.acceptAnnotations();
            this.multiExpect({
                ParensCloseSymbolToken: token => {
                    this.checkCannotHaveAnnotationsHere();
                    this.nextToken();
                    finished = true;
                    parensCloseToken = token;
                },
                IdentifierToken: () => {
                    const field = this.parseField();
                    if (argNames.has(field.name)) {
                        throw new ParserError(`Cannot redeclare argument '${field.name}'`);
                    }
                    argNames.add(field.name);
                    fieldsAndSpreads.push(field);
                    this.multiExpect({
                        ParensCloseSymbolToken: token => {
                            this.checkCannotHaveAnnotationsHere();
                            this.nextToken();
                            finished = true;
                            parensCloseToken = token;
                        },
                        CommaSymbolToken: () => this.nextToken(),
                    });
                },
                SpreadSymbolToken: () => {
                    this.checkCannotHaveAnnotationsHere();
                    this.nextToken();
                    const identToken = this.expect(token_1.IdentifierToken);
                    this.nextToken();
                    if (!/[A-Z]/u.test(identToken.value[0])) {
                        throw new ParserError(`Expected a type but found ${JSON.stringify(identToken.value)} at ${identToken.location}`);
                    }
                    fieldsAndSpreads.push(new ast_1.Spread(new ast_1.TypeReference(identToken.value).at(identToken)).at(identToken));
                    this.multiExpect({
                        ParensCloseSymbolToken: token => {
                            this.checkCannotHaveAnnotationsHere();
                            this.nextToken();
                            finished = true;
                            parensCloseToken = token;
                        },
                        CommaSymbolToken: () => this.nextToken(),
                    });
                },
            });
        }
        for (const annotation of annotations) {
            if (annotation instanceof ast_1.ArgDescriptionAnnotation) {
                const arg = fieldsAndSpreads.find(x => x instanceof ast_1.Field && x.name === annotation.argName);
                if (!arg) {
                    throw new ParserError(`Argument '${annotation.argName}' not found, at ${annotation.location}`);
                }
                arg.annotations.push(new ast_1.DescriptionAnnotation(annotation.text).atLocation(annotation.location));
            }
        }
        annotations = annotations.filter(ann => !(ann instanceof ast_1.ArgDescriptionAnnotation));
        let returnType = new ast_1.VoidPrimitiveType().at(parensCloseToken);
        if (this.token instanceof token_1.ColonSymbolToken) {
            this.nextToken();
            returnType = this.parseType();
        }
        const op = new ast_1.FunctionOperation(name, fieldsAndSpreads, returnType);
        op.annotations = annotations;
        return op;
    }
    parseEnum() {
        this.checkCannotHaveAnnotationsHere();
        const enumToken = this.expect(token_1.EnumKeywordToken);
        this.nextToken();
        this.expect(token_1.CurlyOpenSymbolToken);
        this.nextToken();
        const enumType = new ast_1.EnumType([]).at(enumToken);
        let finished = false;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        while (!finished) {
            this.acceptAnnotations();
            this.multiExpect({
                CurlyCloseSymbolToken: () => {
                    this.checkCannotHaveAnnotationsHere();
                    this.nextToken();
                    finished = true;
                },
                IdentifierToken: token => {
                    const enumValue = new ast_1.EnumValue(token.value).at(token);
                    enumValue.annotations = this.annotations;
                    this.annotations = [];
                    enumType.values.push(enumValue);
                    this.nextToken();
                    if (!(this.token instanceof token_1.ParensOpenSymbolToken)) {
                        return;
                    }
                    this.nextToken();
                    const fieldNames = new Set();
                    const fields = [];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    while (this.token && this.token.maybeAsIdentifier() instanceof token_1.IdentifierToken) {
                        const field = this.parseField();
                        // "tag" is a reserved name on tagged enum fields and can't be used.
                        if (field.name === "tag") {
                            field.name = "_tag";
                        }
                        if (fieldNames.has(field.name)) {
                            throw new ParserError(`Cannot redeclare argument '${field.name}'`);
                        }
                        fieldNames.add(field.name);
                        fields.push(field);
                        if (this.token instanceof token_1.CommaSymbolToken) {
                            this.nextToken();
                        }
                        else {
                            break;
                        }
                    }
                    enumValue.struct = new ast_1.StructType(fields).atLocation(enumValue.location);
                    this.expect(token_1.ParensCloseSymbolToken);
                    this.nextToken();
                },
            });
        }
        return enumType;
    }
    parseField() {
        const nameToken = this.expect(token_1.IdentifierToken);
        this.nextToken();
        this.expect(token_1.ColonSymbolToken);
        this.nextToken();
        const { annotations } = this;
        this.annotations = [];
        const type = this.parseType();
        const field = new ast_1.Field(nameToken.value, type).at(nameToken);
        field.annotations = annotations;
        while (this.token instanceof token_1.ExclamationMarkSymbolToken) {
            this.nextToken();
            switch (this.expect(token_1.IdentifierToken).value) {
                case "secret":
                    field.secret = true;
                    break;
                default:
                    throw new ParserError(`Unknown field mark !${this.token.value} at ${this.token.location}`);
            }
            this.nextToken();
        }
        return field;
    }
    parseStruct() {
        const openingToken = this.expect(token_1.CurlyOpenSymbolToken);
        this.nextToken();
        const fieldsAndSpreads = [];
        const fieldNames = new Set();
        let finished = false;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        while (!finished) {
            this.acceptAnnotations();
            this.multiExpect({
                CurlyCloseSymbolToken: () => {
                    this.checkCannotHaveAnnotationsHere();
                    this.nextToken();
                    finished = true;
                },
                IdentifierToken: () => {
                    const field = this.parseField();
                    if (fieldNames.has(field.name)) {
                        throw new ParserError(`Cannot redeclare field '${field.name}'`);
                    }
                    fieldNames.add(field.name);
                    fieldsAndSpreads.push(field);
                },
                SpreadSymbolToken: () => {
                    this.checkCannotHaveAnnotationsHere();
                    this.nextToken();
                    const identToken = this.expect(token_1.IdentifierToken);
                    this.nextToken();
                    if (!/[A-Z]/u.test(identToken.value[0])) {
                        throw new ParserError(`Expected a type but found ${JSON.stringify(identToken.value)} at ${identToken.location}`);
                    }
                    fieldsAndSpreads.push(new ast_1.Spread(new ast_1.TypeReference(identToken.value).at(identToken)).at(identToken));
                },
            });
        }
        return new ast_1.StructType(fieldsAndSpreads).at(openingToken);
    }
    parseType() {
        this.checkCannotHaveAnnotationsHere();
        let result = this.multiExpect({
            CurlyOpenSymbolToken: () => this.parseStruct(),
            EnumKeywordToken: () => this.parseEnum(),
            IdentifierToken: token => {
                this.nextToken();
                if (!/[A-Z]/u.test(token.value[0])) {
                    throw new ParserError(`Expected a type but found ${JSON.stringify(token.value)} at ${token.location}`);
                }
                return new ast_1.TypeReference(token.value).at(token);
            },
            PrimitiveTypeToken: token => {
                this.nextToken();
                const primitiveClass = utils_1.primitiveToAstClass.get(token.value);
                if (primitiveClass) {
                    return new primitiveClass().at(token);
                }
                throw new ParserError(`BUG! Should handle primitive ${token.value}`);
            },
        });
        while (this.token instanceof token_1.ArraySymbolToken || this.token instanceof token_1.OptionalSymbolToken) {
            this.multiExpect({
                ArraySymbolToken: token => (result = new ast_1.ArrayType(result).at(token)),
                OptionalSymbolToken: token => (result = new ast_1.OptionalType(result).at(token)),
            });
            this.nextToken();
        }
        return result;
    }
}
exports.Parser = Parser;
