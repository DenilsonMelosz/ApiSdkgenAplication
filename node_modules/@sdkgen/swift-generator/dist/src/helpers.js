"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRxMethod = exports.generateMethodSignature = exports.generateErrorClass = exports.generateClass = exports.generateErrorType = exports.generateEnum = exports.generateJsonRepresentation = exports.mangle = exports.generateSwiftTypeName = void 0;
const parser_1 = require("@sdkgen/parser");
function generateSwiftTypeName(type) {
    switch (type.constructor) {
        case parser_1.IntPrimitiveType:
            return "Int";
        case parser_1.UIntPrimitiveType:
            return "UInt";
        case parser_1.MoneyPrimitiveType:
            return "Int64";
        case parser_1.FloatPrimitiveType:
            return "Double";
        case parser_1.BigIntPrimitiveType:
            return "Decimal";
        case parser_1.DatePrimitiveType:
        case parser_1.DateTimePrimitiveType:
            return "Date";
        case parser_1.BoolPrimitiveType:
            return "Bool";
        case parser_1.BytesPrimitiveType:
            return "Data";
        case parser_1.StringPrimitiveType:
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
            return "String";
        case parser_1.VoidPrimitiveType:
            return "Void";
        case parser_1.JsonPrimitiveType:
            return "AnyCodable";
        case parser_1.OptionalType:
            return `${generateSwiftTypeName(type.base)}?`;
        case parser_1.ArrayType: {
            return `[${generateSwiftTypeName(type.base)}]`;
        }
        case parser_1.StructType:
        case parser_1.EnumType:
            return `API.${type.name}`;
        case parser_1.TypeReference:
            return generateSwiftTypeName(type.type);
        default:
            throw new Error(`BUG: generateSwiftTypeName with ${type.constructor.name}`);
    }
}
exports.generateSwiftTypeName = generateSwiftTypeName;
function mangle(fieldName) {
    const mangleList = [
        "associatedtype",
        "deinit",
        "extension",
        "inout",
        "let",
        "in",
        "as",
        "break",
        "class",
        "continue",
        "protocol",
        "Protocol",
        "rethrows",
        "throws",
        "static",
        "do",
        "else",
        "false",
        "for",
        "guard",
        "func",
        "if",
        "internal",
        "struct",
        "subscript",
        "repeat",
        "is",
        "nil",
        "Any",
        "associativity",
        "convenience",
        "import",
        "return",
        "super",
        "self",
        "Self",
        "throw",
        "true",
        "try",
        "typealias",
        "switch",
        "case",
        "default",
        "defer",
        "fallthrough",
        "optional",
        "var",
        "while",
        "catch",
        "dynamic",
        "didSet",
        "Set",
        "fileprivate",
        "lazy",
        "get",
        "init",
        "required",
        "right",
        "param",
        "property",
        "receiver",
        "set",
        "left",
        "where",
        "final",
        "infix",
        "indirect",
        "open",
        "operator",
        "override",
        "private",
        "postfix",
        "public",
        "mutating",
        "none",
        "nonmutating",
        "precedence",
        "prefix",
        "Type",
        "unowned",
        "weak",
        "willSet",
    ];
    if (mangleList.includes(fieldName)) {
        return `_${fieldName}`;
    }
    return fieldName;
}
exports.mangle = mangle;
function generateJsonRepresentation(type, fieldName) {
    switch (type.constructor) {
        case parser_1.StringPrimitiveType:
        case parser_1.CpfPrimitiveType:
        case parser_1.CnpjPrimitiveType:
        case parser_1.EmailPrimitiveType:
        case parser_1.HtmlPrimitiveType:
        case parser_1.UrlPrimitiveType:
        case parser_1.UuidPrimitiveType:
        case parser_1.HexPrimitiveType:
        case parser_1.Base64PrimitiveType:
        case parser_1.XmlPrimitiveType:
        case parser_1.IntPrimitiveType:
        case parser_1.UIntPrimitiveType:
        case parser_1.MoneyPrimitiveType:
        case parser_1.FloatPrimitiveType:
        case parser_1.BoolPrimitiveType:
            return `${fieldName}`;
        case parser_1.OptionalType:
            return `${fieldName} == nil ? nil : ${generateJsonRepresentation(type.base, `${fieldName}!`)}`;
        case parser_1.DatePrimitiveType:
            return `SdkgenHelper.encodeDate(date: ${fieldName})`;
        case parser_1.DateTimePrimitiveType:
            return `SdkgenHelper.encodeDateTime(date: ${fieldName})`;
        case parser_1.EnumType:
            return `${fieldName}.rawValue`;
        case parser_1.TypeReference:
            return `${generateJsonRepresentation(type.type, `${fieldName}`)}`;
        case parser_1.StructType:
            return `${fieldName}.toJSON()`;
        case parser_1.ArrayType:
            return `${fieldName}.map({ return ${generateJsonRepresentation(type.base, "$0")} })`;
        case parser_1.JsonPrimitiveType:
            return `try? ${fieldName}.toJson()`;
        case parser_1.VoidPrimitiveType:
            return `nil`;
        case parser_1.BytesPrimitiveType:
            return `${fieldName}.base64EncodedString()`;
        default:
            throw new Error(`BUG: No result found for generateJsonRepresentation with ${type.constructor.name}`);
    }
}
exports.generateJsonRepresentation = generateJsonRepresentation;
function generateEnum(type) {
    let str = `    public enum ${type.name}: String, Codable {\n`;
    str += type.values
        .map(x => {
        return `        case ${mangle(x.value)} = "${x.value}"`;
    })
        .join(`\n`);
    str += `\n    }\n`;
    return str;
}
exports.generateEnum = generateEnum;
function generateErrorType(types) {
    let str = `    public enum ErrorType: String, Codable {\n`;
    str += types
        .map(x => {
        return `        case ${mangle(x)} = "${x}"`;
    })
        .join(`\n`);
    str += `\n    }\n`;
    return str;
}
exports.generateErrorType = generateErrorType;
function generateConstructor(type) {
    let str = `        init(`;
    str += type.fields.map(field => `${mangle(field.name)}: ${generateSwiftTypeName(field.type)}`).join(", ");
    str += `) {\n`;
    str += type.fields.map(field => `            self.${mangle(field.name)} = ${mangle(field.name)}`).join("\n");
    str += `\n        }\n`;
    return str;
}
function generateToJson(type) {
    let str = `        func toJSON() -> [String: Any] {\n`;
    str += `            var json = [String: Any]()\n`;
    str += type.fields.map(field => `            json["${mangle(field.name)}"] = ${generateJsonRepresentation(field.type, field.name)}`).join("\n");
    str += `\n            return json`;
    str += `\n        }\n`;
    return str;
}
function generateClass(type) {
    return `    public struct ${type.name}: Codable {\n${type.fields
        .map(field => `        var ${mangle(field.name)}: ${generateSwiftTypeName(field.type)}`)
        .join("\n")}\n\n${generateConstructor(type)}\n${generateToJson(type)}\n    }\n`;
}
exports.generateClass = generateClass;
function generateErrorClass() {
    return `    public class Failure: Error {
        var message: String?
        var code: Int?
        var type: ErrorType?
    \n        init(message: String?, code: Int?, type: String?) {
            self.message = message
            self.code = code
            if let typeString = type {
              self.type = ErrorType(rawValue: typeString) ?? nil
            }
        }
    }\n`;
}
exports.generateErrorClass = generateErrorClass;
function generateMethodSignature(op) {
    const argsString = op.args
        .map((arg) => {
        return `${mangle(arg.name)}: ${generateSwiftTypeName(arg.type)}`;
    })
        .concat([
        `timeoutSeconds: Double?`,
        `callback: ((_ result: ${op.returnType instanceof parser_1.VoidPrimitiveType ? "API.Result<API.NoReply>" : `API.Result<${generateSwiftTypeName(op.returnType)}>`}) -> Void)?`,
    ]);
    return `    func ${mangle(op.name)}(${argsString.join(", ")})`;
}
exports.generateMethodSignature = generateMethodSignature;
function generateRxMethod(op) {
    const argsString = op.args
        .map((arg) => {
        return `${mangle(arg.name)}: ${generateSwiftTypeName(arg.type)}`;
    })
        .concat([`timeoutSeconds: Double? = nil`]);
    let str = `    static func ${mangle(op.name)}(${argsString.join(", ")}) -> ${op.returnType instanceof parser_1.VoidPrimitiveType
        ? "Observable<API.Result<API.NoReply>>"
        : `Observable<API.Result<${generateSwiftTypeName(op.returnType)}>>`} {\n`;
    str += `        return Observable.create { observer -> Disposable in\n`;
    str += `            API.calls.${mangle(op.name)}(${op.args
        .map((arg) => {
        return `${mangle(arg.name)}: ${mangle(arg.name)}`;
    })
        .concat([`timeoutSeconds: timeoutSeconds`])
        .join(`, `)}) { result in \n`;
    str += `                observer.on(.next(result))\n`;
    str += `                observer.on(.completed)\n`;
    str += `            }\n`;
    str += `            return Disposables.create()\n`;
    str += `        }\n`;
    str += `    }\n`;
    return str;
}
exports.generateRxMethod = generateRxMethod;
