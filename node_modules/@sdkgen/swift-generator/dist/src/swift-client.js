"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSwiftClientSource = void 0;
const parser_1 = require("@sdkgen/parser");
const helpers_1 = require("./helpers");
function generateSwiftClientSource(ast, withRxExtension) {
    let code = `import Foundation\nimport SdkgenRuntime\n`;
    code += withRxExtension ? `import RxSwift\nimport RxCocoa\n\n` : `\n`;
    code += `protocol APICallsProtocol {\n`;
    code += ast.operations
        .filter(op => op.annotations.every(ann => !(ann instanceof parser_1.HiddenAnnotation)))
        .map(op => {
        return `${(0, helpers_1.generateMethodSignature)(op)}`;
    })
        .join("\n");
    code += `\n}\n\n`;
    code += `class API: SdkgenResponse {

    static var calls = Calls(baseUrl: "")
    static var baseUrl: String? {
        didSet {
            self.calls = Calls(baseUrl: baseUrl ?? "")
        }
    }
    
    override init() {
      super.init()
    }\n\n`;
    for (const type of ast.enumTypes) {
        code += (0, helpers_1.generateEnum)(type);
        code += "\n";
    }
    for (const type of ast.structTypes) {
        code += (0, helpers_1.generateClass)(type);
        code += "\n";
    }
    const errorTypeEnumEntries = [];
    const connectionError = new parser_1.ErrorNode("Connection", new parser_1.VoidPrimitiveType());
    errorTypeEnumEntries.push(connectionError.name);
    for (const error of ast.errors) {
        errorTypeEnumEntries.push(error.name);
    }
    if (errorTypeEnumEntries.length > 0) {
        code += (0, helpers_1.generateErrorType)(errorTypeEnumEntries);
        code += "\n";
    }
    code += (0, helpers_1.generateErrorClass)();
    code += "\n";
    code += `    public enum Result<T> {
      case success(T)
      case failure(Failure)
    }\n\n`;
    code += `    public class Calls: SdkgenHttpClient, APICallsProtocol {

        override init(baseUrl: String) {
            super.init(baseUrl: baseUrl)
        }\n\n`;
    code += ast.operations
        .filter(op => op.annotations.every(ann => !(ann instanceof parser_1.HiddenAnnotation)))
        .map(op => {
        let impl = ``;
        impl += `    ${(0, helpers_1.generateMethodSignature)(op)} {\n`;
        if (op.args.length > 0) {
            impl += `            var jsonArgs = [String: Any]()\n`;
            impl += op.args
                .map(arg => `            jsonArgs["${(0, helpers_1.mangle)(arg.name)}"] = ${(0, helpers_1.generateJsonRepresentation)(arg.type, (0, helpers_1.mangle)(arg.name))}`)
                .join(`\n`);
        }
        else {
            impl += `            let jsonArgs = [String: Any]()`;
        }
        impl += `\n\n`;
        impl += `            makeRequest("${op.name}", jsonArgs, timeoutSeconds, completion: { (value: ${op.returnType instanceof parser_1.VoidPrimitiveType ? "API.NoReply" : (0, helpers_1.generateSwiftTypeName)(op.returnType)}) in\n`;
        impl += `                callback?(API.Result.success(value))\n`;
        impl += `            }, onError: { error in\n`;
        impl += `                callback?(API.Result.failure(API.Failure(message: error.message, code: error.code, type: error.type)))\n`;
        impl += `            })`;
        impl += `\n        }\n`;
        return impl;
    })
        .join("\n");
    code += `    }\n`;
    code += `}\n`;
    if (withRxExtension) {
        code += `\n`;
        code += `extension API: ReactiveCompatible {}\n\n`;
        code += `extension Reactive where Base: API {\n`;
        code += ast.operations
            .filter(op => op.annotations.every(ann => !(ann instanceof parser_1.HiddenAnnotation)))
            .map(op => {
            return `${(0, helpers_1.generateRxMethod)(op)}`;
        })
            .join("\n");
        code += `}\n`;
    }
    return code;
}
exports.generateSwiftClientSource = generateSwiftClientSource;
